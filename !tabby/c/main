/*******************************************************************************

File        : c.main

Date        : Tuesday 11th January 2022

Author      : Gavin Cawley and Cameron Cawley

Description : Program to manage multiple (!SrcEdit) windows by grouping them 
              all under an external tab bar.

History     : 07/11/2021 v0.0.1 - Started work.
              21/11/2021 v0.1.0 - First properly working prototype.
              27/11/2021 v0.2.0 - Windows can now be independently released
                                  from the tab bar, but needs tidying up.
              27/11/2021 v0.2.1 - Fixed a bug when a non-active tab is released
                                  and the release of non-active windows made 
                                  more consistent in behaviour and minor 
                                  refactoring.
              28/11/2021 v0.3.0 - Logging can now be disabled by a preprocessor
                                  directive (DEBUG).  Now suppports scrolling
                                  of the tab pane.
              30/11/2021 v0.4.0 - Window title bar now hidden beneath tabby 
                                  window.
              04/12/2021 v0.5.0 - A small window now intercepts drags on the
                                  adjust size icon, so that !tabby now has
                                  complete control over the dimensions of the
                                  active window.
              05/12/2021 v0.6.0 - When resizing the active window, the drag is
                                  limited to prevent the maximum extent of the
                                  window being exceded, but does not work 
                                  correctly for !draw windows.
              06/12/2021 v0.6.1 - Fixed bug in resizing, so now works correctly
                                  with !draw.
              09/12/2021 v0.6.2 - Now monitors the active window in case it
                                  is resized unexpectedly (e.g. in !draw 
                                  following a change of paper dimensions).
                                  Started work on copying the title of the
                                  active window into the gui title bar.
              11/12/2021 v0.7.0 - Title bar now mirrors the title of the
                                  active window.
              12/12/2021 v0.7.1 - Adjust window now hidden if no active tab.
                                  TabPane new redrawn correctly when a tab is
                                  released.
              18/12/2021 v0.7.2 - If the active window is above the gui in the
                                  window stack, the gui is reopened to bring it
                                  beneath again.  This can happen, for example,
                                  if throwback is being used with the DDE.
              18/12/2021 v0.8.0 - Tab pane scroll icons now hidden when not
                                  useful.
              19/12/2021 v0.8.1 - Minor bug-fix, tab pane now re-opens
                                  correctly if active window changes size
                                  unexpectedly.
              25/12/2021 v0.9.0 - Refactored to allow multiple instances. A
                                  !tabby instance is prevented from capturing
                                  another !tabby instance so that bad things
                                  don't happen.  Maintains a list of active
                                  instances, so that all captured windows can
                                  be released when the task exits.
              26/12/2021 v0.9.1 - Adjust size intercept window now has an
                                  sicon/psicon sprite icon.
              27/12/2021 v0.9.2 - Hopefully now closes down correctly.
              28/12/2021 v0.9.3 - Prevented from capturing a pane (e.g. a
                                  !draw tool pane) or another !tabby instance
                                  (including it's active window).
              31/12/2021 v0.9.4 - Fixed minor bug in adjusting the size of the
                                  active window relating to the minimum size.
              08/01/2022 v0.9.5 - Now more robust against captured windows 
                                  being deleted (or the task owning the window
                                  closing down).
              09/01/2022 v0.9.6 - Sprites now in application sprite area (CC).
              09/01/2022 v1.0.0 - Initial release version.
              11/01/2022 v1.0.1 - Spoke too soon, minor bug fix required ;o)

To do       : (a) Allow tabs to be rearranged by dragging.

              (b) Refactor tab pane so that tabs can be the minimum width for
                  the label, and move tabs, rather than reuse them.

              (c) Need to refactor at some point to eliminate memory leaks,
                  these are not too serious at the moment, so it can wail until
                  the design has stabilised/congealed sufficiently.

              (d) Add a configuration option so that the user can decide whether
                  the windows are closed or just released when the tabby bar is
                  closed or the tab is closed.

              (e) Resizing the active window should implement the maximising
                  effect of dragging to the bottom and right edges of the
                  screen.

              (f) The colour of the active tab should indicate whether the
                  active window has the input focus (the title bar of the
                  !tabby window cannot do this as it is managed by the wimp)?

              (g) The adjust window should have the sicon/psicon sprite from
                  system sprites so that it is consistent with the wimp theme.

              (h) Add a toggle size icon.

              (i) Support for older low-res screen modes.

Acks        : Many thanks to Stuart Swales for his help and advice.

*******************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
                 
#include "alarm.h"
#include "wimp.h"
#include "wimpt.h"
#include "resspr.h"
#include "baricon.h"
#include "res.h"
#include "event.h"
#include "menu.h"
#include "dbox.h"
#include "win.h"
#include "template.h"

#define DEBUG 1

#if DEBUG
#include "logger.h"
#else
#define LOG(...)
#endif
   
#define APP_NAME "Tabby"
#define MENU_ITEMS ">Info,Quit"

#define STATE_SEARCHING 0
#define STATE_CAPTURING 1
#define STATE_LOCKED    2
                 
#define MAX_TABS (256)
#define TAB_WIDTH (278)
                    
#define IMENU_INFO 1
#define IMENU_QUIT 2

menu imenu;       

typedef struct TabStr
{  
   wimp_w handle;

   int scx, scy;   // scroll bar positions

   wimp_t task;    // window owner
}
Tab;
          
typedef struct TabbyStr
{
   // information about tabs

   Tab tab[MAX_TABS];

   int n;

   int active;   // the currently active tab (-1 if no tabs)               
                            
   // information about windows

   wimp_w gui_handle;
   wimp_w tabPane_handle;
   wimp_w active_handle;
   wimp_w adjust_handle;

   wimp_wstate gui_state;
   wimp_wstate active_state;
   wimp_wstate tabPane_state;
   wimp_wstate adjust_state;

   wimp_winfo active_winfo;

   wimp_t active_task;

   // state information
                                          
   int state;

   char* gui_title;

   wimp_w window;

   // pointer to next instance in the list

   struct TabbyStr *next;
}
Tabby;                 

Tabby *instances = NULL;

wimp_t filer_task;     


// forward declarations of functions (To do - refactor away if feasible)

void gui_open(Tabby *tabby, wimp_openstr* openstr);

void gui_closeDown(Tabby *tabby);

Tabby* gui_create(void);

void tabPane_deleteTab(Tabby *instance, int tab);
                                                                        

/*******************************************************************************
*                                                                              * 
*                           Misc. Support Functions                            * 
*                                                                              * 
*******************************************************************************/


/*******************************************************************************

Function    : min

Parameters  : int - first integer
              int - second integer     

Returns     : int - smaller of the two integer arguments

Description : Return the value of the smaller of the two integer arguments.

*******************************************************************************/

int min(int x, int y)
{
   return x < y ? x : y;
}

/*******************************************************************************

Function    : max

Parameters  : int - first integer
              int - second integer     

Returns     : int - larger of the two integer arguments

Description : Return the value of the larger of the two integer arguments.

*******************************************************************************/

int max(int x, int y)
{
   return x > y ? x : y;
}

/*******************************************************************************

Function    : strdup

Parameters  : char* - pointer to string to be duplicated     

Returns     : char* - pointer to duplicate string

Description : Make a duplicate of a null-terminated string.  The duplicate is 
              allocated from the heap, so the caller has responsibility for 
              freeing it when no longer required.

*******************************************************************************/

#ifndef strdup

char *strdup(const char *s)
{
   size_t size = strlen(s) + 1;

   char *str = (char*)malloc(size);

   if (str != NULL) 
   {
      memcpy(str, s, size);
   }
 
   return str;
}

#endif


/*******************************************************************************

Function    : findTask

Parameters  : char* - name of WIMP task

Returns     : wimp_t - task handle

Description : Returns the task handle of the named task, or zero if no such
              task is currently running.

*******************************************************************************/

#define TaskManager_EnumerateTasks 0x42681

wimp_t findTask(char *task)
{
   int buffer[16];

   os_regset regs;

   regs.r[0] = 0;
                         
   do
   { 
      regs.r[1] = (int)&buffer;
      regs.r[2] = 64;

      wimpt_complain(os_swix(TaskManager_EnumerateTasks, &regs));

      for (int *block = buffer; block < (int*)regs.r[1]; block += 4)
      {                               
         if (strcmp(task, (char*)block[1]) == 0)
         {
            return block[0];
         }
      }  
   }
   while (regs.r[0] >= 0);

   return 0;
}
                                                                                
/*******************************************************************************

Function    : identifyOwner 

Parameters  : wimp_w - window handle

Returns     : wimp_t - task handle 

Description : Returns the task handle of the task that owns the specified
              window.  It is not clear what value is returned if an invalid
              window handle is used.

*******************************************************************************/

#define Wimp_SendMessage 0x400E7
                                                            
wimp_t identifyOwner(wimp_w window)
{   
   os_regset regs;

   wimp_msghdr msg; 

   msg.size     = 20;   
   msg.your_ref = 0;  

   regs.r[0] = wimp_EACK; 
   regs.r[1] = (int)&msg;
   regs.r[2] = window;

   wimpt_complain(os_swix(Wimp_SendMessage, &regs));

   return (wimp_t)regs.r[2];   
}

/*******************************************************************************

Function    : resizeIcon 

Parameters  : wimp_w    - window handle
              wimp_i    - icon handle
              wimp_box* - pointer to new bounding box

Returns     : void

Description : Resize (or move) and existing icon

*******************************************************************************/

#define Wimp_ResizeIcon 0x400FC
                                                            
void resizeIcon(wimp_w window, wimp_i icon, wimp_box *bbox)
{   
   os_regset regs; 

   regs.r[0] = window; 
   regs.r[1] = icon;
   regs.r[2] = bbox->x0;
   regs.r[3] = bbox->y0;
   regs.r[4] = bbox->x1;
   regs.r[5] = bbox->y1;

   wimpt_complain(os_swix(Wimp_ResizeIcon, &regs)); 
}

/*******************************************************************************

Function    : forceTitleBarRedraw 

Parameters  : wimp_w    - window handle

Returns     : void

Description : Use the extended syntax of wimp_force_redraw to force a redraw
              of the title bar of a window.

*******************************************************************************/
                                                            
void forceTitleBarRedraw(wimp_w handle)
{
   wimp_redrawstr redrawstr;

   redrawstr.w      = handle;
   redrawstr.box.x0 = 0x4B534154;
   redrawstr.box.y0 = 3;
   
   wimp_force_redraw(&redrawstr); 
}

/*******************************************************************************

Function    : intersects

Parameters  : wimp_box - pointer to bounding box of first window
              wimp_box - pointer to bounding box of second window

Returns     : BOOL - TRUE if boxes intersect and FALSE otherwise

Description : Determine whether one window overlaps another on-screen.

*******************************************************************************/

BOOL intersects(wimp_box *x, wimp_box *y)
{                          
   if (x->x0 > y->x1) return FALSE;
   if (x->x1 < y->x0) return FALSE;
   if (x->y0 > y->y1) return FALSE;
   if (x->y1 < y->y0) return FALSE; 
   
   return TRUE;
}
                                                                                
/*******************************************************************************

Function    : different

Parameters  : wimp_box - pointer to box 
              wimp_box - pointer to box 

Returns     : BOOL - TRUE if boxes are different and FLASE otherwise

Description : Determine whether two wimp_box structures differ.  Typically used
              to determine whether a window has been moved or resized.

*******************************************************************************/
                                                    
BOOL different(wimp_box *x, wimp_box *y)
{
   return ((x->x0 != y->x0) ||
           (x->y0 != y->y0) ||
           (x->x1 != y->x1) ||
           (x->y1 != y->y1));
} 

/*******************************************************************************

Function    : isTerminated

Parameters  : char* - pointer to window information struct
              int   - length of buffer

Returns     : BOOL - TRUE if buffer is null-terminated string, otherwise FALSE

Description : Determine whether the string contained in a buffer is null 
              terminated.

*******************************************************************************/ 

BOOL isTerminated(char *buffer, int bufflen)
{               
   for (int i = 0; i < bufflen; i++)
   {
      if (buffer[i] < 0x20)
      {
         return TRUE;
      }
   }

   return FALSE;
}                                                    

/*******************************************************************************

Function    : getWindowTitle

Parameters  : wimp_winfo* - pointer to window information struct
              wimp_t      - task handle of the window owner
              char*       - pointer to buffer 
              int         - length of buffer

Returns     : void

Description :

*******************************************************************************/

void getWindowTitle(wimp_winfo *info, wimp_t owner, char *buffer, int bufflen)
{                                       
   char *src =  info->info.title.indirecttext.buffer;

   int srclen = info->info.title.indirecttext.bufflen;
                         
   wimp_t task = wimpt_task();

   // transfer the title into the buffer                       

   for (int n = min(srclen, bufflen); n <= bufflen; n++)
   {
      wimpt_complain(wimp_transferblock(owner, src, task, buffer, n));

      if (isTerminated(buffer, n))
      {
         break;
      }
   }

   buffer[bufflen-1] = '\0';  
}


    
/*******************************************************************************

Function    : checkCapturedWindows

Parameters  : void

Returns     : void

Description : Check all captured windows to make sure they still exist. If the
              handle of a captured window is no longer valid it could be that
              the task owning the window has deleted it, but it could also be
              the case that the owner has exited, in which case there may be
              other captured windows that no longer exist.  This function
              deletes any tab for which the captured window no longer exists 
              and leaves all !tabby instances in a consistent state.

To do       : Determine whether wimp_get_wind_state is the cheapest way to
              discover if a window handle is still valid.

*******************************************************************************/

void checkCapturedWindows(void)
{                                                 
   for (Tabby *tab = instances; tab != NULL; tab = tab->next)
   {
      // go through tabs in reverse as some tabs may be deleted as we go

      for (int i = tab->n - 1; i >= 0; i--)
      {
         wimp_wstate wstate;

         os_error *err = wimp_get_wind_state(tab->tab[i].handle, &wstate);

         if (err != NULL)
         {                                      
            tab->tab[i].handle = 0;

            tabPane_deleteTab(tab, i);
         }                                               
      }
   }
}

/*******************************************************************************

Function    : getWindowState

Parameters  : wimp_w - window handle
              wimp_wstate* - pointer to struct describing window state 

Returns     : os_error* - pointer to struct describing error

Description : Get the state of the specified window, but if the window handle
              is not valid, this may indicate that one or more captured windows
              may no longer exist.  If this is the case, a call is made to
              checkCapturedWindows to delete tabs as necessary and leave all
              !tabby instances in a consistent state.

Notes       : This function must be used whenever the state of a captured
              window is requried.

*******************************************************************************/
   
#define ILLEGAL_WINDOW_HANDLE (648)

os_error* getWindowState(wimp_w handle, wimp_wstate *wstate)
{
   os_error *err = wimp_get_wind_state(handle, wstate);

   if (err != NULL && err->errnum == ILLEGAL_WINDOW_HANDLE)
   {                         
       LOG("guiWindowState", " err = %d : msg = '%s'", err->errnum, 
          err->errmess);

      // checkCapturedWindows();      
   }                      

   return err;
}

/*******************************************************************************

Function    : getWindowInfo

Parameters  : wimp_winfo* - pointer to struct describing window information 

Returns     : os_error* - pointer to struct describing error

Description : Get the window information of a window, but if the window handle
              is not valid, this may indicate that one or more captured windows
              may no longer exist.  If this is the case, a call is made to
              checkCapturedWindows to delete tabs as necessary and leave all
              !tabby instances in a consistent state.

Notes       : This function must be used whenever the window information of a 
              captured window is requried.

*******************************************************************************/
   
os_error* getWindowInfo(wimp_winfo *winfo)
{
   os_error *err = wimp_get_wind_info(winfo);

   if (err != NULL && err->errnum == ILLEGAL_WINDOW_HANDLE)
   {          
       LOG("guiWindowInfo", " err = %d : msg = '%s'", err->errnum, 
          err->errmess);

      checkCapturedWindows();      
   }                      

   return err;
}

/*******************************************************************************

Function    : sendOpenWindowMessage

Parameters  : wimp_w        - window handle
              wimp_openstr* - pointer to window parameter structure

Returns     : os_error* - pointer to struct describing error

Description : Send an Open_Window_Request message to the specified window.

*******************************************************************************/
                               
os_error* sendOpenWindowRequest(wimp_w handle, wimp_openstr* openstr)
{
   os_regset regs;

   regs.r[0] = (int)wimp_EOPEN;
   regs.r[1] = (int)openstr;
   regs.r[2] = (int)handle;

   os_error* err = os_swix(Wimp_SendMessage, &regs);        

   if (err != NULL && err->errnum == ILLEGAL_WINDOW_HANDLE)
   {                     
       LOG("sendOpenWindowRequest", " err = %d : msg = '%s'", err->errnum, 
          err->errmess);

      // checkCapturedWindows();      
   }                      

   return err;
}


/*******************************************************************************
*                                                                              * 
*                            Instance List Management                          * 
*                                                                              * 
*******************************************************************************/


Tabby* instance_new(void)
{ 
   Tabby *tabby = gui_create();
                
   tabby->next = instances;
   instances   = tabby;

   return tabby;
}                       

void instance_delete(Tabby *tabby)
{ 
   if (instances == tabby)
   {   
      instances = tabby->next;   

      gui_closeDown(tabby);
   }
   else if (instances != NULL)
   {
      for (Tabby *t = instances; t->next != NULL; t = t->next)
      { 
         if (t->next == tabby)
         {                
            t->next = tabby->next;
 
            gui_closeDown(tabby);

            break;
         }
      }
   }
}


/*******************************************************************************
*                                                                              * 
*                                    Tab Pane                                  * 
*                                                                              * 
*******************************************************************************/


/*******************************************************************************

Function    : tabPane_position

Parameters  : Tabby*    - pointer to !tabby gui instance
              wimp_box* - pointer to bounding box of the !tabby gui window

Returns     : void

Description : Position the tab pane according to the position and dimensions 
              of the !tabby gui window and the number of tabs.  If there are
              no tabs or the first tab is visible, the tab pane covers the
              left scroll icon.  If there are no tabs, or the last tab is
              visible, the tab pane covers the right scroll icon.

*******************************************************************************/
                                 
void tabPane_position(Tabby *tabby, wimp_box *box)
{
   int width = box->x1 - box->x0;

   int left  = (tabby->n == 0 || tabby->tabPane_state.o.x <= 0) ? 68 : 124;

   int right = (tabby->n*TAB_WIDTH < width+tabby->tabPane_state.o.x-left) ? 0 : 60;

   tabby->tabPane_state.o.box.x0 = box->x0 + left;  
   tabby->tabPane_state.o.box.x1 = box->x1 - right;    
   tabby->tabPane_state.o.box.y0 = box->y0; 
   tabby->tabPane_state.o.box.y1 = box->y1; 
}               
         
/*******************************************************************************

Function    : 

Parameters  :   

Returns     : 

Description : 

*******************************************************************************/          

void tabPane_scrollLeft(Tabby *tabby)
{
   tabby->tabPane_state.o.x -= TAB_WIDTH;

   if (tabby->tabPane_state.o.x <= 0)
   {
      tabPane_position(tabby, &tabby->gui_state.o.box);
   }

   gui_open(tabby, &tabby->gui_state.o);
}        

/*******************************************************************************

Function    : 

Parameters  :   

Returns     : 

Description : 

*******************************************************************************/ 

void tabPane_scrollRight(Tabby *tabby)
{                         
   tabby->tabPane_state.o.x += TAB_WIDTH;   

   if (tabby->tabPane_state.o.x < TAB_WIDTH)
   {
      tabPane_position(tabby, &tabby->gui_state.o.box);
   }

   gui_open(tabby, &tabby->gui_state.o);
}
             
/*******************************************************************************

Function    : tabPane_extractLabel

Parameters  : char* - pointer to window title

Returns     : char* - pointer to tab label allocated on the heap

Description : Determine a suitable tab label from the title string of a 
              window managed by !tabby.  If the title is a file path, then
              the label is the name of the file, however if the path ends
              c.<file> or h.<file>, the label will be <file>.h or <file>.c
              respectively.  The label is allocated from the heap, so the
              caller has responsibility for freeing it when no longer required.

              Note that labels are always returned as 16 byte blocks so that
              tab labels can always be copied safely.

*******************************************************************************/
                      
char *tabPane_extractLabel(char *path)
{  
   char *token[256];

   char buffer[256];

   int n = 0;

   for (char *tok = strtok(path, "."); tok != NULL; tok = strtok(NULL, "."))
   {
      token[n++] = tok;
   }
                           
   if (n > 1)
   {
      if (strcmp(token[n-2], "c") == 0 || 
          strcmp(token[n-2], "h") == 0)
      {
         sprintf(buffer, "%s.%s", token[n-1], token[n-2]);
      }   
      else
      {
         sprintf(buffer, "%s", token[n-1]);
      }
   }                      
   else
   {
      sprintf(buffer, "%s", path);
   }
                    
   // return label in a fixed size (16 byte) buffer
       
   char *label = (char*)malloc(16);
   
   memcpy(label, buffer, 15);

   label[15] = '\0';

   return strdup(buffer); 
}

/*******************************************************************************

Function    : tabPane_forceRedraw

Parameters  : void

Returns     : void

Description : Force a redraw of the entire tab bar.
                  
To do       : A bit of a hack at the moment, needs to be properly 
              re-implemented.

*******************************************************************************/

void tabPane_forceRedraw(Tabby *tabby)
{
   wimp_redrawstr redrawstr;

   redrawstr.w      = tabby->tabPane_handle;
   redrawstr.box.x0 = -0;
   redrawstr.box.y0 = -64;
   redrawstr.box.x1 = +4096;
   redrawstr.box.y1 = +4096;
   
   wimpt_complain(wimp_force_redraw(&redrawstr));                  
}

/*******************************************************************************

Function    : tabPane_releaseWindow

Parameters  : Tabby* - pointer to !tabby gui instance
              int    - tab number

Returns     : void

Description : Release a window associated with a tab.  The window is re-opened
              at the top of the window stack, displaced downwards and to the
              right, to make it clear that it is no longer managed by the tab
              bar.

*******************************************************************************/
                                                            
void tabPane_releaseWindow(Tabby *tabby, int tab)
{
   wimp_wstate wstate;
                          
   // just in case captured window has already dissapeared

   if (wimp_get_wind_state(tabby->tab[tab].handle, &wstate) == NULL)
   {       
      wstate.o.behind = -1;
      wstate.o.x      = tabby->tab[tab].scx;
      wstate.o.y      = tabby->tab[tab].scy;
      wstate.o.box.x0 = tabby->active_state.o.box.x0 + 64; 
      wstate.o.box.y0 = tabby->active_state.o.box.y0 - 64;
      wstate.o.box.x1 = tabby->active_state.o.box.x1 + 64;
      wstate.o.box.y1 = tabby->active_state.o.box.y1 - 64;
      
      sendOpenWindowRequest(tabby->tab[tab].handle, &wstate.o); 
   }
}
                                                                     
/*******************************************************************************

Function    : tabPane_selectTab 

Parameters  : Tabby* - pointer to a !tabby gui instance
              int    - index of tab to become the active tab

Returns     : void

Description : Select a new active tab, changing the colour an appearance of the
              icon, and making the corresponding window visible.  If another
              tab was previously active, the colour and appearance of the
              icon is changed and the corresponding window is hidden.  In that
              case, the dimensions and position of the new active window is
              made the same as those of the old active window.

*******************************************************************************/

void tabPane_selectTab(Tabby *tabby, int tab)
{  
   wimp_redrawstr r;
   
   wimp_icon info;

   if (tab != tabby->active)
   {  
      if (tabby->active != -1)
      {                 
         // change colour and appearance of the old active tab

         wimpt_complain(wimp_get_icon_info(tabby->tabPane_handle, 
                           tabby->active*2, &info)); 

         info.data.indirecttext.validstring[1] = '1';

         wimpt_complain(wimp_set_icon_state(tabby->tabPane_handle, 
                           2*tabby->active, 
                           (wimp_iconflags)((1U << 28) | wimp_IFILLED), 
                           (wimp_iconflags)(0xF0000000U | wimp_IFILLED)));    
         
         // hide the old active window (which may have dissapeared)

         if (wimp_get_wind_state(tabby->active_handle, 
                &tabby->active_state) == NULL)
         {                       
            tabby->active_state.o.behind = -3;

            sendOpenWindowRequest(tabby->active_handle, &tabby->active_state.o);

            // store scroll positions for when it is next active

            tabby->tab[tabby->active].scx = tabby->active_state.o.x;
            tabby->tab[tabby->active].scy = tabby->active_state.o.y;
         }
      }

      // change the active tab

      tabby->active        = tab;                                  
      tabby->active_handle = tabby->tab[tabby->active].handle;
      tabby->active_task   = tabby->tab[tabby->active].task;

      // change colour and appearance of the new active tab

      wimpt_complain(wimp_get_icon_info(tabby->tabPane_handle, 2*tab, &info)); 

      info.data.indirecttext.validstring[1] = '2';

      wimpt_complain(wimp_set_icon_state(tabby->tabPane_handle, 2*tab, 
                        (wimp_iconflags)((12U << 28) | wimp_IFILLED), 
                        (wimp_iconflags)(0xF0000000U | wimp_IFILLED))); 
  
      // change the title of the gui window

      tabby->active_winfo.w = tabby->active_handle;

      wimp_winfo *winfo = (wimp_winfo*)(1 + (char*)&tabby->active_winfo);
       
      if (wimp_get_wind_info(winfo) != NULL)
      {
         if (tabby->active_winfo.info.titleflags & wimp_INDIRECT)
         {    
            wimp_t owner = identifyOwner(tabby->active_handle);
             
            getWindowTitle(&tabby->active_winfo, owner, tabby->gui_title, 256);
         }
         else
         {
            tabby->gui_title[0] = '\0';

            strncat(tabby->gui_title, tabby->active_winfo.info.title.text, 12);
         }

         forceTitleBarRedraw(tabby->gui_handle);
      }

      // re-open adjust window
       
      tabby->adjust_state.o.behind = tabby->gui_handle;
      
      wimpt_noerr(wimp_open_wind(&tabby->adjust_state.o));

      // re-open the new active tab              
      
      tabby->active_state.o.w      = tabby->active_handle;   
      tabby->active_state.o.behind = tabby->adjust_handle;
      tabby->active_state.o.x      = tabby->tab[tabby->active].scx;
      tabby->active_state.o.y      = tabby->tab[tabby->active].scy;
        
      sendOpenWindowRequest(tabby->active_handle, &tabby->active_state.o);
   }

   r.w      = tabby->tabPane_handle;
   r.box.x0 = tabby->tabPane_state.o.box.x0;
   r.box.y0 = tabby->tabPane_state.o.box.y0;
   r.box.x1 = tabby->tabPane_state.o.box.x1;
   r.box.y1 = tabby->tabPane_state.o.box.y1;

   wimpt_complain(wimp_force_redraw(&r));     

   gui_open(tabby, &tabby->gui_state.o);
}

/*******************************************************************************

Function    : tabPane_deleteTab 

Parameters  : Tabby* - pointer to a !tabby gui instance
              int    - index of tab to be deleted

Returns     : void

Description : Delete a tab.  It isn't clear at the moment whether the correct
              behaviour should be to close the window or just detach it from 
              the tab bar.  For the moment, I'll go with detatching the window
              as it is easier and more conducive to debugging.
                                               
              Rather than re-form the tab bar, just relabel the existing icons
              and delete the last one, which hopefully is the most efficient
              approach.

*******************************************************************************/
                       
void tabPane_deleteTab(Tabby *tabby, int tab)
{  
   // deselect the tab if currently active
                                         
   if (tabby->n == 1)
   {
      tabby->active        = -1;   
      tabby->active_handle = 0;        
                     
      // hide adjust window

      tabby->adjust_state.o.behind = -3;
      
      wimpt_complain(wimp_open_wind(&tabby->adjust_state.o));
   }
   else if (tab == tabby->active)
   {                 
      tabPane_selectTab(tabby, tab == 0 ? 1 : (tab-1));
   }            

   // release window
                         
   if (tabby->tab[tab].handle != 0)
   {
      tabPane_releaseWindow(tabby, tab);
   }

   // update the tab bar     
       
   for (int i = tab + 1; i < tabby->n; i++)
   {         
      if (i == tabby->active)
      {
         tabby->active--;
      }           

      tabby->tab[i-1].handle = tabby->tab[i].handle;
      tabby->tab[i-1].scx    = tabby->tab[i].scx;
      tabby->tab[i-1].scy    = tabby->tab[i].scy;

      wimp_icon icon1, icon2;

      wimpt_complain(wimp_get_icon_info(tabby->tabPane_handle, 
                       (i-1)*2, &icon1));
 
      wimpt_complain(wimp_get_icon_info(tabby->tabPane_handle, 
                        i*2, &icon2)); 

      strncpy(icon1.data.indirecttext.buffer, 
              icon2.data.indirecttext.buffer, 15);

      strncpy(icon1.data.indirecttext.validstring, 
              icon2.data.indirecttext.validstring, 2);

      wimpt_complain(wimp_set_icon_state(tabby->tabPane_handle, 2*(i-1), 
                        icon2.flags, (wimp_iconflags)0xFFFFFFFF));
   }

   tabby->n--;               

   wimpt_complain(wimp_delete_icon(tabby->tabPane_handle, 2*tabby->n));
   wimpt_complain(wimp_delete_icon(tabby->tabPane_handle, 2*tabby->n+1));

   tabPane_forceRedraw(tabby);

   gui_open(tabby, &tabby->gui_state.o);
}           

/*******************************************************************************

Function    : tabPane_mouseClickHandler

Parameters  : Tabby*         - pointer to a !tabby gui instance
              wimp_mousestr* - pointer to struct describing mouse event
              wimp_bbits     - additional information about mouse event

Returns     : void

Description : Respond to mouse button events over the tab pane, to determine
              which tab is clicked on, and make that the active tab.

*******************************************************************************/

static void tabPane_mouseClickHandler(Tabby *tabby,
                                      wimp_mousestr *ms, 
                                      wimp_bbits mbits)
{     
   wimp_icon info;

   if (ms->i%2 == 0)
   {
      // tab clicked

      wimpt_complain(wimp_get_icon_info(tabby->tabPane_handle, ms->i, &info));
     
      char *valid = info.data.indirecttext.validstring;
            
      if (valid[1] == '1')
      {
         tabPane_selectTab(tabby, ms->i/2);
      } 
   }
   else
   {
      // tab close button clicked      

      tabPane_deleteTab(tabby, ms->i/2);
   }
}          

/*******************************************************************************

Function    : tabPane_eventHandler 

Parameters  : wimp_eventstr* - pointer to struct describing the event
              void*          - pointer to workspace (a !tabby gui instance)

Returns     : void

Description : Main event handler for the tab pane of a !tabby window.

*******************************************************************************/

void tabPane_eventHandler(wimp_eventstr *e, void *handle)
{                              
   Tabby *tabby = (Tabby*)handle;

   switch(e->e)
   {
      case wimp_EOPEN:   // maximise or minimise window 
      {
         wimpt_noerr(wimp_open_wind(&e->data.o));

         break;
      }
      case wimp_ECLOSE:   // close window
      {
         wimpt_noerr(wimp_close_wind(e->data.o.w));
       
         break;
      } 
      case wimp_EBUT:
      {        
         tabPane_mouseClickHandler(tabby, &(e->data.but.m), e->data.but.b);

         break;
      }
   }
}

/*******************************************************************************

Function    : tabPane_create

Parameters  : Tabby* - pointer to a !tabby gui instance

Returns     : void

Description : Create a new tab pane for a !tabby window.

*******************************************************************************/

void tabPane_create(Tabby *tabby)
{                        
   wimp_wind *window = template_syshandle("TabPane");

   if (window == 0)
   {
      exit(EXIT_FAILURE);
   }

   if (wimpt_complain(wimp_create_wind(window, &tabby->tabPane_handle)) != 0)
   {
      exit(EXIT_FAILURE);
   }

   win_register_event_handler(tabby->tabPane_handle, 
      tabPane_eventHandler, (void*)tabby);

   tabby->n = 0;
}

/*******************************************************************************

Function    : tabPane_addTab

Parameters  : Tabby* - pointer to a !tabby gui instance
              wimp_w - handle of a window to be managed by !tabby

Returns     : void

Description : Create a new tab on the tab bar for the specified window and
              select it as the active tab.

*******************************************************************************/
                                 
void tabPane_addTab(Tabby *tabby, wimp_w handle)
{                              
   // get info about the window
                      
   wimp_winfo info;

   info.w = handle;
   
   wimpt_complain(wimp_get_wind_info(&info));
      
   char *label;

   wimp_t task = identifyOwner(handle);

   if (info.info.titleflags & wimp_INDIRECT)
   {                                                                  
      char buffer[512];

      getWindowTitle(&info, task, buffer, 512);

      label = tabPane_extractLabel(buffer);
   }  
   else
   {                              
      char buffer[13];          

      buffer[0] = '\0';

      strncat(buffer, info.info.title.text, 12);

      label = strdup(buffer);
   }    

   // create tab icon

   wimp_icreate icreatestr;

   wimp_i icon;
                                                      
   icreatestr.w = tabby->tabPane_handle;                   
                      
   icreatestr.i.flags  = (wimp_iconflags)
                       ( wimp_ITEXT
                       | wimp_IVCENTRE
                       | wimp_INDIRECT
                       | wimp_IBORDER
                       | wimp_BCLICKAUTO << 12
                       | 7U << 24U     // foreground colour
                       | 1U << 28U);   // background colour

   icreatestr.i.data.indirecttext.buffer      = label;
   icreatestr.i.data.indirecttext.validstring = strdup("R1"); 
   icreatestr.i.data.indirecttext.bufflen     = strlen(label);
   icreatestr.i.box.x0 = tabby->n*TAB_WIDTH;
   icreatestr.i.box.y0 = -52 -16;
   icreatestr.i.box.x1 = icreatestr.i.box.x0 + TAB_WIDTH;
   icreatestr.i.box.y1 = -16;
       
   wimp_create_icon(&icreatestr, &icon);

   // create tab close icon

   icreatestr.i.flags  = (wimp_iconflags)
                       ( wimp_ISPRITE
                       | wimp_IHCENTRE
                       | wimp_IVCENTRE
                       | wimp_BCLICKAUTO << 12);

   strncpy(icreatestr.i.data.sprite_name, "close", 11); 
   icreatestr.i.box.x0 = icreatestr.i.box.x0 + TAB_WIDTH - 30;
   icreatestr.i.box.y0 = -52 + 16 -16;
   icreatestr.i.box.x1 = icreatestr.i.box.x0 + 13;
   icreatestr.i.box.y1 = -16 -16;

   wimp_create_icon(&icreatestr, &icon);

   // record window handle and scroll bar positions

   tabby->tab[tabby->n].handle = handle;
   tabby->tab[tabby->n].scx    = info.info.scx;
   tabby->tab[tabby->n].scy    = info.info.scy;
   tabby->tab[tabby->n].task   = task;

   tabPane_selectTab(tabby, tabby->n++); 
          
   // re-open the tab pane

   gui_open(tabby, &tabby->gui_state.o);
}                                                                                


/*******************************************************************************
*                                                                              * 
*                               Main GUI Functions                             * 
*                                                                              * 
*******************************************************************************/


/*******************************************************************************

Function    : gui_setState

Parameters  : Tabby* - pointer to a !tabby gui instance
              int    - new state

Returns     : void

Description : Update the state of the !tabby GUI, including updating the
              red/yellow/green LED.

*******************************************************************************/
                                                                                
void gui_setState(Tabby *tabby, int newState)
{
   wimp_icon info;

   wimp_get_icon_info(tabby->gui_handle, 0, &info);

   char *valid = info.data.indirecttext.validstring;

   switch (newState)
   {          
      case STATE_SEARCHING:
      {         
         sprintf(valid, "R5;Sred_led,red_led");       

         tabby->state = STATE_SEARCHING;

         break;
      }
      case STATE_CAPTURING:
      {                 
         sprintf(valid, "R5;Syellow_led,yellow_led");       
         
         tabby->state = STATE_CAPTURING;

         break;
      }
      default:                   
      { 
         sprintf(valid, "R5;Sgreen_led,green_led");       

         tabby->state = STATE_LOCKED;
      }
   }                     

   // redraw the icon
     
   wimp_redrawstr r;

   r.w      = tabby->gui_handle;
   r.box.x0 = 0;
   r.box.y0 = -64;
   r.box.x1 = +64;
   r.box.y1 = 0;

   wimp_force_redraw(&r);
}

/*******************************************************************************

Function    : gui_open

Parameters  : Tabby*        - pointer to a !tabby gui instance
              wimp_openstr* - pointer to struct describing window parameters

Returns     : void

Description : Open a !tabby window, and the associated tab pane, so that it is 
              visible on-screen.

*******************************************************************************/

void gui_open(Tabby *tabby, wimp_openstr *openstr)
{                            
   // has the width of the gui changed? 

   int oldWidth = tabby->gui_state.o.box.x1 - tabby->gui_state.o.box.x0;
   int newWidth = openstr->box.x1    - openstr->box.x0;

   if (newWidth != oldWidth)
   {
      // re-position right scroll icon

      wimp_box bbox;

      bbox.x0 = newWidth - 40 - 14;
      bbox.y0 = -60;
      bbox.x1 = newWidth - 14;
      bbox.y1 = -20;

      resizeIcon(tabby->gui_handle, 2, &bbox);

      wimp_redrawstr redrawstr;

      redrawstr.w      = tabby->gui_handle;
      redrawstr.box.x0 = min(newWidth, oldWidth) - 40 - 14;
      redrawstr.box.y0 = -60;
      redrawstr.box.x1 = max(newWidth, oldWidth) - 14;
      redrawstr.box.y1 = -20;
        
      wimp_force_redraw(&redrawstr); 
   }

   // open adjust size cover

   if ((tabby->active_handle != 0) &&
       (tabby->active_winfo.info.flags & wimp_WSIZE))
   {                                                       
      int yoff = (tabby->active_winfo.info.flags & wimp_WHSCR) ? 40 : 0; 
      
      tabby->adjust_state.o.box.x0 = tabby->active_state.o.box.x1;   
      tabby->adjust_state.o.box.y0 = tabby->active_state.o.box.y0 - yoff;
      tabby->adjust_state.o.box.x1 = tabby->active_state.o.box.x1 + 40;
      tabby->adjust_state.o.box.y1 = tabby->adjust_state.o.box.y0 + 40; 
      tabby->adjust_state.o.behind = openstr->behind;                 

      tabby->tabPane_state.o.behind = tabby->adjust_handle;      
   }                                      
   else
   {                       
      tabby->adjust_state.o.behind = -3;                                    

      tabby->tabPane_state.o.behind = openstr->behind;
   }

   wimpt_noerr(wimp_open_wind(&tabby->adjust_state.o));

   // open tab pane                       
         
   tabPane_position(tabby, &openstr->box);

   wimpt_noerr(wimp_open_wind(&tabby->tabPane_state.o));
                                        
   // open gui window
    
   tabby->gui_state.o.behind = tabby->tabPane_handle;

   memcpy(&tabby->gui_state.o.box, &openstr->box, sizeof(wimp_box));
         
   wimpt_noerr(wimp_open_wind(&tabby->gui_state.o));

   // re-open active window beneath the gui window

   if (tabby->active_handle != 0)
   { 
      int height = tabby->active_state.o.box.y1 - tabby->active_state.o.box.y0;
            
      tabby->active_state.o.box.x1 = tabby->gui_state.o.box.x1 - 40;
      tabby->active_state.o.box.y1 = tabby->gui_state.o.box.y0 - 2;
      tabby->active_state.o.box.x0 = tabby->gui_state.o.box.x0;
      tabby->active_state.o.box.y0 = tabby->active_state.o.box.y1 - height;
      tabby->active_state.o.behind = tabby->gui_handle;

      sendOpenWindowRequest(tabby->active_handle, &tabby->active_state.o);
   }
}

/*******************************************************************************

Function    : gui_closeDown
        
Parameters  : Tabby* - pointer to a !tabby gui instance

Returns     : void

Description : Called when a !tabby window is closed in order to restore all of
              the hidden windows. 

To do       : Free memory allocated to this !tabby window.

*******************************************************************************/

void gui_closeDown(Tabby *tabby)
{
   // gui no longer needs to monitor the active window
                                                     
   alarm_removeall(tabby);

   // bring back all of the windows
     
   for (int i = 0; i < tabby->n; i++)
   {
      wimp_get_wind_state(tabby->tab[i].handle, &tabby->active_state); 
      
      tabby->active_state.o.w      = tabby->tab[i].handle;
      tabby->active_state.o.behind = -1;
      tabby->active_state.o.w      = tabby->tab[i].handle;
      tabby->active_state.o.x      = tabby->tab[i].scx;
      tabby->active_state.o.y      = tabby->tab[i].scy;
      
      sendOpenWindowRequest(tabby->tab[i].handle, &tabby->active_state.o);
   }

   // can dispose of all three windows   

   wimpt_noerr(wimp_delete_wind(tabby->gui_handle));
   wimpt_noerr(wimp_delete_wind(tabby->tabPane_handle));
   wimpt_noerr(wimp_delete_wind(tabby->adjust_handle));
}
   
/*******************************************************************************

Function    : gui_eventHandler

Parameters  : wimp_eventstr* - pointer to struct describing the event
              void*          - pointer to workspace (a !tabby gui instance)

Returns     : void

Description : Main event handler for the !tabby window.

*******************************************************************************/

void gui_eventHandler(wimp_eventstr *e, void *handle)
{                                                       
   Tabby *tabby = (Tabby*)handle;

   switch(e->e)
   {
      case wimp_EOPEN:   // maximise or minimise window 
      {
         gui_open(tabby, &(e->data.o));
                                            
         break;
      }
      case wimp_ECLOSE:   // close window
      {
         instance_delete(tabby);
       
         break;
      }
      case wimp_EBUT:   // mouse button change
      {     
         switch (e->data.but.m.i)
         {                                 
            case 0: // LED
            {                
               if (tabby->state == STATE_LOCKED)
               {
                  gui_setState(tabby, STATE_SEARCHING);
               }
               else
               {        
                  gui_setState(tabby, STATE_LOCKED);
               }

               break;
            }
            case 1: // left scroll button
            {                
               tabPane_scrollLeft(tabby);

               break;
            }
            case 2: // LED
            {                
               tabPane_scrollRight(tabby);

               break;
            }
         }

         break;
      }
   }
}

/*******************************************************************************

Function    : 

Parameters  : 

Returns     : 

Description : 

*******************************************************************************/
 
void adjust_eventHandler(wimp_eventstr *e, void *handle)
{                                                                                
   Tabby *tabby = (Tabby*)handle;
            
   static int x, y;   // drag offsets 

   switch(e->e)                                 
   {   
      case wimp_ENULL:   // react to null event
      {   
         // adjust window is being dragged to re-size active window
            
         wimp_mousestr mousestr;

         wimp_openstr openstr;

         wimp_get_point_info(&mousestr);
           
         memcpy(&openstr, &tabby->gui_state.o, sizeof(wimp_openstr));
                                                 
         int yoff = (tabby->active_winfo.info.flags & wimp_WHSCR) ? 40 : 0; 

         tabby->active_state.o.box.x1 = mousestr.x + x;
         tabby->active_state.o.box.y0 = mousestr.y + y + yoff;
         openstr.box.x1               = tabby->active_state.o.box.x1 + 40;
         openstr.behind               = -1;

         gui_open(tabby, &openstr);    

         break;
      }
      case wimp_EOPEN:    
      {
         wimpt_noerr(wimp_open_wind(&e->data.o));
                                    
         break;
      }
      case wimp_ECLOSE:   // close window
      {
         gui_closeDown(tabby);

         wimpt_noerr(wimp_close_wind(e->data.o.w));
         wimpt_noerr(wimp_close_wind(tabby->tabPane_handle));
       
         break;
      }                                          
      case wimp_EBUT:
      {
         if (e->data.but.m.bbits == 0x40)
         {                          
            // update the state of the active window 

            wimp_get_wind_state(tabby->active_handle, &tabby->active_state); 

            // update the window information
                   
            tabby->active_winfo.w = tabby->active_handle;

            wimpt_complain(wimp_get_wind_info(&tabby->active_winfo));

            // initiate drag operation

            wimp_dragstr dragstr;

            x = tabby->adjust_state.o.box.x0 - e->data.but.m.x;
            y = tabby->adjust_state.o.box.y0 - e->data.but.m.y;

            int yoff = (tabby->active_winfo.info.flags & wimp_WHSCR) ? 40 : 0; 

            wimp_box parent;

            parent.x0 = tabby->active_state.o.box.x0 
                      + max(420, (tabby->active_winfo.info.minsize >> 16));  
            parent.y0 = tabby->active_state.o.box.y1
                      - tabby->active_winfo.info.ex.y1
                      + tabby->active_winfo.info.ex.y0
                      - yoff - y + 4;
            parent.x1 = tabby->active_state.o.box.x0 
                      + tabby->active_winfo.info.ex.x1
                      - tabby->active_winfo.info.ex.x0
                      - x;
            parent.y1 = tabby->active_state.o.box.y1 
                      - max(124, tabby->active_winfo.info.minsize & 0xFFFF)
                      - y - 40;

            dragstr.window    = tabby->adjust_handle;
            dragstr.box.x0    = tabby->adjust_state.o.box.x0;
            dragstr.box.y0    = tabby->adjust_state.o.box.y0;
            dragstr.box.x1    = tabby->adjust_state.o.box.x1;
            dragstr.box.y1    = tabby->adjust_state.o.box.y1;
            dragstr.parent.x0 = parent.x0;
            dragstr.parent.y0 = parent.y0;
            dragstr.parent.x1 = parent.x1;
            dragstr.parent.y1 = parent.y1;
            dragstr.type      = wimp_USER_HIDDEN;

            wimp_drag_box(&dragstr);

            win_claim_idle_events(tabby->adjust_handle);
         }

         break;
      }
   }
}


/*******************************************************************************

Function    : adjust_unknownEventProcessor

Parameters  : wimp_eventstr - pointer to struct of event information
              void*         - pointer to workspace (!tabby instance struct)

Returns     : BOOL - TRUE if event fully handled and otherwise FALSE.

Description : Handler of unknown events for the adjust size interceptor
              window of a !tabby instance.  It's main function is to handle
              the end of a user drag event, in which case idle events are
              no longer required.

*******************************************************************************/

BOOL adjust_unknownEventProcessor(wimp_eventstr *e, void *handle)
{                                        
   Tabby *tabby = (Tabby*)handle;

   switch(e->e)
   {                                      
      case wimp_EUSERDRAG:
      {
         // drag operation finished, so null events no longer required

         win_claim_idle_events(tabby->adjust_handle-1);

         return TRUE;
      }
   }

   return FALSE;
}

/*******************************************************************************

Function    : gui_create

Parameters  : void

Returns     : Tabby* - pointer to a new !tabby gui instance

Description : Create a new !tabby instance.

*******************************************************************************/
           
Tabby* gui_create(void)
{                                       
   Tabby *tabby = (Tabby*)malloc(sizeof(Tabby));

   // create the main gui               

   template *template = template_copy(template_find("Window"));

   wimp_wind *window = &template->window;

   if (window == 0)
   {
      exit(EXIT_FAILURE);
   }

   if (wimpt_complain(wimp_create_wind(window, &tabby->gui_handle)) != 0)
   {
      exit(EXIT_FAILURE);
   }

   win_register_event_handler(tabby->gui_handle, gui_eventHandler, tabby);

   // create the tab pane
                                       
   tabPane_create(tabby);
   
   // create the adjust window
         
   window = template_syshandle("adjustSize");

   if (window == 0)
   {
      exit(EXIT_FAILURE);
   }

   window->colours[0] = 0xFF;

   if (wimpt_complain(wimp_create_wind(window, &tabby->adjust_handle)) != 0)
   {
      exit(EXIT_FAILURE);
   }

   win_register_event_handler(tabby->adjust_handle, 
      adjust_eventHandler, tabby);

   win_add_unknown_event_processor(adjust_unknownEventProcessor, tabby);

   // get initial window states

   wimp_get_wind_state(tabby->gui_handle,     &tabby->gui_state);
   wimp_get_wind_state(tabby->adjust_handle,  &tabby->adjust_state); 
   wimp_get_wind_state(tabby->tabPane_handle, &tabby->tabPane_state);
                         
   // get pointer to gui title icon buffer
                      
   wimp_winfo winfo;

   winfo.w = tabby->gui_handle;
       
   wimpt_complain(wimp_get_wind_info((wimp_winfo*)(1 + (char*)&winfo)));
   
   tabby->gui_title = winfo.info.title.indirecttext.buffer;

   LOG("gui_create", "title = %p", tabby->gui_title);
     
   // gui initially empty

   gui_setState(tabby, STATE_LOCKED);

   tabby->active        = -1;
   tabby->active_handle = 0;         
   tabby->window        = 0;

   return tabby;
}

/*******************************************************************************

Function    : gui_isCapturable

Parameters  : wimp_wstate - pointer to a window state struct

Returns     : void

Description : Function to determine whether a window is eligible to be captured
              by a !tabby instance.  Another !tabby instance is not capturable,
              nor is the tabPane or adjust window of this !tabby instance.#
              Only the active window of a !tabby instance can be above the
              gui window in the window stack, so we don't need to check any
              inactive windows captured by any !tabby instance.  We also don't
              want to capture panes, but only the main window of an app (e.g.
              we want to capture a !draw drawing, rather than the tool pane).

*******************************************************************************/

BOOL gui_isCapturable(wimp_wstate *wstate)
{  
   // don't capture a !tabby instance or it's active window

   for (Tabby *t = instances; t != NULL; t = t->next)
   {           
      if (wstate->o.w == t->gui_handle)     return FALSE;
      if (wstate->o.w == t->tabPane_handle) return FALSE;
      if (wstate->o.w == t->adjust_handle)  return FALSE;
      if (wstate->o.w == t->active_handle)  return FALSE;
   }

   // must have an adjust size button

   return (wstate->flags & wimp_WSIZE);
}
                                           
/*******************************************************************************

Function    : gui_monitor

Parameters  : int   - current time
              void* - pointer to workspace (a !tabby gui instance)

Returns     : void

Description : Callback called by the alarm to repidly monitor the active 
              window, and respond appropriately e.g. if the title of the window
              changes, whenever the current state is STATE_LOCKED.  If the 
              state is STATE_SEARCHING, the application is waiting for a window 
              to be dragged over the tab bar, when this happens, the window is
              identified, the state is changed to STATE_CAPTURING and there
              is a delay of 1 second for the user to let go of the window.
              If the state is STATE_CAPTURING, a new active tab is created
              and the system moves back into STATE_LOCKED.

              The handles of all of the captured windows are checked for
              validity.  If they are no longer valid it probably means they 
              have been deleted by the task owning the window or the owner
              task has exited.  If that happens, checkCapturedWindows deletes
              tabs as required and ensures all !tabby instances are left in
              a consistent state.  No other action is to required other than
              to make sure no errors are generated elsewhere, this function
              will detect the deleted captured window quickly enough for the
              user not to notice.

*******************************************************************************/

void gui_monitor(int time, void *handle)
{                      
   Tabby *tabby = (Tabby*)handle;

   int delay = 10;

   // check to see if any of the windows have unexpectedly closed

   checkCapturedWindows();

   // perform appropriate behaviour for the current state
              
   if (tabby->state == STATE_SEARCHING)
   {           
      // seek window to capture by iterating through the window stack
                         
      wimpt_complain(wimp_get_wind_state(tabby->gui_handle, &tabby->gui_state));
      
      wimp_wstate wstate;
                                        
      wstate.o.behind = tabby->gui_state.o.behind;

      while (wstate.o.behind != -1)         
      { 
         tabby->window = wstate.o.behind;

         wimpt_complain(wimp_get_wind_state(tabby->window, &wstate));  
                                          
         if (intersects(&tabby->gui_state.o.box, &wstate.o.box))
         {
            if (gui_isCapturable(&wstate))
            {
               delay = 100;        
               
               gui_setState(tabby, STATE_CAPTURING);

               break;
            }
         }
      }
      
   }
   else if (tabby->state == STATE_CAPTURING)
   {
      // re-open captured window beneath the tab bar
                     
      if (tabby->active_handle == 0)
      {                                         
         // just in case window dissapears during capture

         if (wimp_get_wind_state(tabby->window, &tabby->active_state) != NULL) 
         {
            int height = tabby->active_state.o.box.y1-tabby->active_state.o.box.y0;

            tabby->active_state.o.box.x0 = tabby->gui_state.o.box.x0;
            tabby->active_state.o.box.y0 = tabby->gui_state.o.box.y1 - height;
            tabby->active_state.o.box.x1 = tabby->gui_state.o.box.x1 - 40;
            tabby->active_state.o.box.y1 = tabby->gui_state.o.box.y0 - 2;
            tabby->active_state.o.w      = tabby->window;
            tabby->active_state.o.behind = tabby->adjust_handle;

            // re-open adjust button over the adjust size icon of the active window
      
            tabby->adjust_state.o.box.x0 = tabby->active_state.o.box.x1;
            tabby->adjust_state.o.box.y0 = tabby->active_state.o.box.y0 - 40;  
            tabby->adjust_state.o.box.x1 = tabby->adjust_state.o.box.x0 + 40;
            tabby->adjust_state.o.box.y1 = tabby->adjust_state.o.box.y0 + 40;
            tabby->adjust_state.o.behind = -1;  

            wimpt_noerr(wimp_open_wind(&tabby->adjust_state.o));
   
            sendOpenWindowRequest(tabby->active_handle, &tabby->active_state.o);
         }
      }

      tabPane_addTab(tabby, tabby->window);      
                                                        
      gui_setState(tabby, STATE_LOCKED);
   }
   else if (tabby->active_handle != 0)
   {
      // has the active window changed size unexpectedly?
                                                              
      wimp_wstate wstate;

      memcpy(&wstate, &tabby->active_state, sizeof(wimp_wstate));

      if (getWindowState(tabby->active_handle, &tabby->active_state) == NULL) 
      {
         if (different(&wstate.o.box, &tabby->active_state.o.box)) 
         {
            wstate.o.box.x0 = tabby->active_state.o.box.x0;
            wstate.o.box.y0 = tabby->active_state.o.box.y1 + 2;
            wstate.o.box.x1 = tabby->active_state.o.box.x1 + 40;
            wstate.o.box.y1 = tabby->active_state.o.box.y1 + 66;

            gui_open(tabby, &wstate.o);
         }
      }

      // has the window title changed? 
                      
      if (tabby->active_task != filer_task)
      {
         wimp_winfo winfo;

         winfo.w = tabby->active_handle;
       
         wimpt_complain(getWindowInfo((wimp_winfo*)(1 + (char*)&winfo)));

         if (winfo.info.titleflags & wimp_INDIRECT)
         {                                                                  
            char buffer[512];
                    
            wimp_t owner = identifyOwner(tabby->active_handle);
             
            getWindowTitle(&winfo, owner, buffer, 512);

            if (strncmp(tabby->gui_title, buffer, 255))
            {
               strncpy(tabby->gui_title, buffer, 256);

               tabby->gui_title[255] = '\0';

               forceTitleBarRedraw(tabby->gui_handle);
            }
         }
      }   

      // is the active window above the main gui in the stack?

      if (!wimp_get_wind_state(tabby->gui_handle, &tabby->gui_state))
      { 
         wimp_wstate wstate;
                                        
         wstate.o.behind = tabby->gui_state.o.behind;

         while (wstate.o.behind != -1)         
         { 
            wimp_w win = wstate.o.behind;

            if (win == tabby->active_handle)
            {
               wimp_get_wind_state(win, &tabby->active_state);                                               
               gui_open(tabby, &tabby->gui_state.o);

               break;
            }
            else
            {
               wimp_get_wind_state(win, &wstate);      
            }
         }
      }
   }
   else
   {
      // there is no active tab

      delay = 10;
   }
   
   // reset alarm for next time

   alarm_set(alarm_timenow() + delay, gui_monitor, tabby);
}


/*******************************************************************************
*                                                                              * 
*                             Icon Bar and Menu                                * 
*                                                                              * 
*******************************************************************************/


/*******************************************************************************

Function    : info_about

Parameters  : void

Returns     : void

Description : Display program information dialog box.

*******************************************************************************/

static void info_about(void)
{
   dbox d = dbox_new("ProgInfo");

   if (d != NULL)
   {
      dbox_show(d);        
      dbox_fillin(d);       
      dbox_dispose(&d);     
   }
}

/*******************************************************************************

Function    : ipremenuproc

Parameters  : void* - pointer to workspace

Returns     : void

Description : Callback used to prepare the menu structure.  Currently just a
              stub.

*******************************************************************************/

static menu ipremenuproc(void *handle)
{
   return imenu;
}

/*******************************************************************************

Function    : imenuproc

Parameters  : void* - pointer to workspace
              char* - hit

Returns     : void

Description : Event handler for clicks on the menu.

*******************************************************************************/

static void imenuproc(void *handle, char *hit)
{
   switch (hit[0])  
   {                
      case IMENU_INFO:
      {
         info_about();

         break;
      }
      case IMENU_QUIT:
      {
         for (Tabby *tabby = instances; tabby != NULL; tabby = tabby->next)
         {
            gui_closeDown(tabby);
         }

         wimp_closedown();

         break;
      }
   }
}

/*******************************************************************************

Function    : icon_left_click

Parameters  : wimp_i 

Returns     : void

Description : Callback called whenever the left mouse button is clicked on 
              the icon on the icon bar.  This is currently unused, but will
              later be implemented to allow multible !tabby tab bars.

*******************************************************************************/

static void icon_left_click(wimp_i icon)
{                                                      
   Tabby *tabby = instance_new();

   tabby->gui_state.o.behind = -1;

   gui_open(tabby, &tabby->gui_state.o);

   // start monitoring 

   alarm_set(alarm_timenow() + 10, gui_monitor, tabby);
}

/*******************************************************************************

Function    : messageEventProcessor

Parameters  : wimp_eventstr* - pointer to struct describing the event
              void*          - pointer to workspace (currently unused)

Returns     : BOOL - TRUE if event fully handled, FALSE otherwise.

Description : Task-level event processor.  In this case it responds to user
              wimp messages sent by other tasks.

*******************************************************************************/

BOOL messageEventProcessor(wimp_eventstr *e, void *handle)
{
   switch (e->e)
   {
      case wimp_ESEND: 
      case wimp_ESENDWANTACK:
      {
         switch (e->data.msg.hdr.action)
         {
            case wimp_MPREQUIT:
            {        
               // make sure all captured windows released before !tabby quits

               for (Tabby *t = instances; t != NULL; t = t->next)
               {
                  gui_closeDown(t);
               }

               return TRUE;
            }
            case wimp_MCLOSEDOWN:
            {        
               wimp_closedown();

               return TRUE;
            }
         }

         return FALSE;
      }
   }

   return FALSE;
}


/*******************************************************************************
*                                                                              * 
*                               Main Function                                  * 
*                                                                              * 
*******************************************************************************/


int main(void)
{                        
  event_setmask((wimp_emask)(wimp_EMREDRAW      |
                             wimp_EMPTRLEAVE    |
                             wimp_EMPTRENTER    |
                             wimp_EMKEY         |
                             wimp_EMSCROLL      |
                             wimp_EMLOSECARET   |
                             wimp_EMGAINCARET   |
                             wimp_EMACK));          
       
   wimpt_init(APP_NAME);

   res_init(APP_NAME);

   resspr_init();

   template_init();              

   dbox_init();     

   alarm_init();

   baricon("!tabby", (int)wimp_spritearea, icon_left_click);

   imenu = menu_new(APP_NAME, MENU_ITEMS);
                    
   if (imenu == NULL)
   {
      return EXIT_FAILURE;
   }

   if (!event_attachmenumaker(win_ICONBAR, ipremenuproc, imenuproc, 0))
   {
      return EXIT_FAILURE;
   }                    

   // register icon menu and middle click handler 

   if (!event_attachmenumaker(win_ICONBAR, ipremenuproc, imenuproc, 0))
   {
      return FALSE;
   }               

   LOG("main", "Hello from %s", "Tabby");

   win_add_unknown_event_processor(messageEventProcessor, NULL);
                                                          
   filer_task = findTask("Filer");

   LOG("main", "Filer task id = %d", filer_task);

   // main even processing loop

   while (TRUE) 
   {
      event_process();
   }
                    
   wimp_closedown();

   return EXIT_SUCCESS;
}

/******************************************************************************/
