/*******************************************************************************

File        : c.main

Date        : Saturday 4th December 2021

Author      : Gavin Cawley

Description : Program to manage multiple (!SrcEdit) windows by grouping them 
              all under an external tab bar.

History     : 07/11/2021 v0.0.1 - Started work.
              21/11/2021 v0.1.0 - First properly working prototype.
              27/11/2021 v0.2.0 - Windows can now be independently released
                                  from the tab bar, but needs tidying up.
              27/11/2021 v0.2.1 - Fixed a bug when a non-active tab is released
                                  and the release of non-active windows made 
                                  more consistent in behaviour and minor 
                                  refactoring.
              28/11/2021 v0.3.0 - Logging can now be disabled by a preprocessor
                                  directive (DEBUG).  Now suppports scrolling
                                  of the tab pane.
              30/11/2021 v0.4.0 - Window title bar now hidden beneath tabby 
                                  window.
              04/12/2021 v0.5.0 - A small window now intercepts drags on the
                                  adjust size icon, so that !tabby now has
                                  complete control over the dimensions of the
                                  active window.
              05/12/2021 v0.6.0 - When resizing the active window, the drag is
                                  limited to prevent the maximum extent of the
                                  window being exceded, but does not work 
                                  correctly for !draw windows.
              06/12/2021 v0.6.1 - Fixed bug in resizing, so now works correctly
                                  with !draw.

To do       : (a) Scroll buttons should only be visible when it is possible to
                  scroll further in that direction.  Make the most of the 
                  available width to display as many tabs as possible.

              (b) Allow tabs to be rearranged by dragging.

              (c) Support for multiple independent tab bars.

              (d) Refactor tab pane so that tabs can be the minimum width for
                  the label, and move tabs, rather than reuse them.

              (e) Need to refactor at some point to eliminate memory leaks,
                  these are not too serious at the moment, so it can wail until
                  the design has stabilised/congealed sufficiently.

              (f) Have the tab bar window title copy that of the active window,
                  and ideally have it match the background colour (perhaps
                  monitor every 100ms or so?  Could then hide the title bar of
                  the window, which would make some aspects of management a bit
                  easier.

              (g) Add a configuration option so that the user can decide whether
                  the windows are closed or just released when the tabby bar is
                  closed or the tab is closed.

              (h) Resizing the active window should implement the maximising
                  effect of dragging to the bottom and right edges of the
                  screen.

Acks        : Many thanks to Stuart Swales for his help and advice.

*******************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
                 
#include "alarm.h"
#include "wimp.h"
#include "wimpt.h"
#include "resspr.h"
#include "baricon.h"
#include "res.h"
#include "event.h"
#include "menu.h"
#include "dbox.h"
#include "win.h"
#include "template.h"

#define DEBUG 1

#if DEBUG
#include "logger.h"
#else
#define LOG(...)
#endif
   
#define APP_NAME "Tabby"
#define MENU_ITEMS ">Info,Quit"
                 
#define MAX_TABS (256)
#define TAB_WIDTH (275)
                    
#define IMENU_INFO 1
#define IMENU_QUIT 2

menu imenu;       

int active = -1;   // the currently active tab (-1 if no tabs)               

wimp_w gui_handle     = 0;
wimp_w tabPane_handle = 0;
wimp_w active_handle  = 0;
wimp_w vscroll_handle = 0;
wimp_w hscroll_handle = 0;
wimp_w adjust_handle  = 0;

wimp_wstate gui_state, active_state, tabPane_state, adjust_state;

wimp_winfo active_winfo;
                 
#define STATE_SEARCHING 0
#define STATE_CAPTURING 1
#define STATE_LOCKED    2
                         
int state = STATE_SEARCHING;

typedef struct TabStr
{  
   wimp_w handle;

   int scx, scy;   // scroll bar positions
}
Tab;
          
typedef struct TabsStr
{
   Tab tab[MAX_TABS];

   int n;

   int active;
}
Tabs;             

Tabs tabs;

char block[32768];


/*******************************************************************************
*                                                                              * 
*                           Misc. Support Functions                            * 
*                                                                              * 
*******************************************************************************/


/*******************************************************************************

Function    : min

Parameters  : int - first integer
              int - second integer     

Returns     : int - smaller of the two integer arguments

Description : Return the value of the smaller of the two integer arguments.

*******************************************************************************/

int min(int x, int y)
{
   return x < y ? x : y;
}

/*******************************************************************************

Function    : max

Parameters  : int - first integer
              int - second integer     

Returns     : int - larger of the two integer arguments

Description : Return the value of the larger of the two integer arguments.

*******************************************************************************/

int max(int x, int y)
{
   return x > y ? x : y;
}

/*******************************************************************************

Function    : strdup

Parameters  : char* - pointer to string to be duplicated     

Returns     : char* - pointer to duplicate string

Description : Make a duplicate of a null-terminated string.  The duplicate is 
              allocated from the heap, so the caller has responsibility for 
              freeing it when no longer required.

*******************************************************************************/

#ifndef strdup

char *strdup(const char *s)
{
   size_t size = strlen(s) + 1;

   char *str = (char*)malloc(size);

   if (str != NULL) 
   {
      memcpy(str, s, size);
   }
 
   return str;
}

#endif

/*******************************************************************************

Function    : sendOpenWindowMessage

Parameters  : wimp_w        - window handle
              wimp_openstr* - pointer to window parameter structure

Returns     : void

Description : Send an Open_Window_Request message to the specified window.

*******************************************************************************/
                        
#define Wimp_SendMessage 0x400E7
       
void sendOpenWindowRequest(wimp_w handle, wimp_openstr* openstr)
{
   os_regset regs;

   regs.r[0] = (int)wimp_EOPEN;
   regs.r[1] = (int)openstr;
   regs.r[2] = (int)handle;

   wimpt_complain(os_swix(Wimp_SendMessage, &regs));
}

/*******************************************************************************

Function    : findTask

Parameters  : char* - name of WIMP task

Returns     : wimp_t - task handle

Description : Returns the task handle of the named task, or zero if no such
              task is currently running.

*******************************************************************************/

#define TaskManager_EnumerateTasks 0x42681

wimp_t findTask(char *task)
{
   int buffer[16];

   os_regset regs;

   regs.r[0] = 0;
                         
   do
   { 
      regs.r[1] = (int)&buffer;
      regs.r[2] = 64;

      wimpt_complain(os_swix(TaskManager_EnumerateTasks, &regs));

      for (int *block = buffer; block < (int*)regs.r[1]; block += 4)
      {                               
         if (strcmp(task, (char*)block[1]) == 0)
         {
            return block[0];
         }
      }  
   }
   while (regs.r[0] >= 0);

   return 0;
}
                                                                                
/*******************************************************************************

Function    : identifyOwner 

Parameters  : wimp_w - window handle

Returns     : wimp_t - task handle 

Description : Returns the task handle of the task that owns the specified
              window.  It is not clear what value is returned if an invalid
              window handle is used.

*******************************************************************************/
                                                            
wimp_t identifyOwner(wimp_w window)
{   
   os_regset regs;

   wimp_msghdr msg; 

   msg.size     = 20;   
   msg.your_ref = 0;  

   regs.r[0] = wimp_EACK; 
   regs.r[1] = (int)&msg;
   regs.r[2] = window;

   wimpt_complain(os_swix(Wimp_SendMessage, &regs));

   return (wimp_t)regs.r[2];   
}

/*******************************************************************************

Function    : resizeIcon 

Parameters  : wimp_w    - window handle
              wimp_i    - icon handle
              wimp_box* - pointer to new bounding box

Returns     : void

Description : Resize (or move) and existing icon

*******************************************************************************/

#define Wimp_ResizeIcon 0x400FC
                                                            
void resizeIcon(wimp_w window, wimp_i icon, wimp_box *bbox)
{   
   os_regset regs; 

   regs.r[0] = window; 
   regs.r[1] = icon;
   regs.r[2] = bbox->x0;
   regs.r[3] = bbox->y0;
   regs.r[4] = bbox->x1;
   regs.r[5] = bbox->y1;

   wimpt_complain(os_swix(Wimp_ResizeIcon, &regs)); 
}

/*******************************************************************************

Function    : intersects

Parameters  : wimp_box - pointer to bounding box of first window
              wimp_box - pointer to bounding box of second window

Returns     : BOOL - TRUE if boxes intersect and FALSE otherwise

Description : Determine whether one window overlaps another on-screen.

*******************************************************************************/

BOOL intersects(wimp_box *x, wimp_box *y)
{                          
   if (x->x0 > y->x1) return FALSE;
   if (x->x1 < y->x0) return FALSE;
   if (x->y0 > y->y1) return FALSE;
   if (x->y1 < y->y0) return FALSE; 
   
   return TRUE;
}
                                                                                
/*******************************************************************************

Function    : different

Parameters  : wimp_box - pointer to box 
              wimp_box - pointer to box 

Returns     : BOOL - TRUE if boxes are different and FLASE otherwise

Description : Determine whether two wimp_box structures differ.  Typically used
              to determine whether a window has been moved or resized.

*******************************************************************************/
                                                    
BOOL different(wimp_box *x, wimp_box *y)
{
   return ((x->x0 != y->x0) ||
           (x->y0 != y->y0) ||
           (x->x1 != y->x1) ||
           (x->y1 != y->y1));
} 


/*******************************************************************************
*                                                                              * 
*                                    Tab Pane                                  * 
*                                                                              * 
*******************************************************************************/
                         
void tabPane_scrollLeft(void)
{
   tabPane_state.o.x -= TAB_WIDTH;

   wimpt_noerr(wimp_open_wind(&tabPane_state.o));

}

void tabPane_scrollRight(void)
{                         
   tabPane_state.o.x += TAB_WIDTH;

   wimpt_noerr(wimp_open_wind(&tabPane_state.o));
}
             
/*******************************************************************************

Function    : tabPane_extractLabel

Parameters  : char* - pointer to window title

Returns     : char* - pointer to tab label allocated on the heap

Description : Determine a suitable tab label from the title string of a 
              window managed by !tabby.  If the title is a file path, then
              the label is the name of the file, however if the path ends
              c.<file> or h.<file>, the label will be <file>.h or <file>.c
              respectively.  The label is allocated from the heap, so the
              caller has responsibility for freeing it when no longer required.

              Note that labels are always returned as 16 byte blocks so that
              tab labels can always be copied safely.

*******************************************************************************/
                      
char *tabPane_extractLabel(char *path)
{  
   char *token[256];

   char buffer[256];

   int n = 0;

   for (char *tok = strtok(path, "."); tok != NULL; tok = strtok(NULL, "."))
   {
      token[n++] = tok;
   }
                           
   if (n > 1)
   {
      if (strcmp(token[n-2], "c") == 0 || 
          strcmp(token[n-2], "h") == 0)
      {
         sprintf(buffer, "%s.%s", token[n-1], token[n-2]);
      }   
      else
      {
         sprintf(buffer, "%s", token[n-1]);
      }
   }                      
   else
   {
      sprintf(buffer, "%s", path);
   }
                    
   // return label in a fixed size (16 byte) buffer
       
   char *label = (char*)malloc(16);
   
   memcpy(label, buffer, 15);

   label[15] = '\0';

   return strdup(buffer); 
}

/*******************************************************************************

Function    : tabPane_forceRedraw

Parameters  : void

Returns     : void

Description : Force a redraw of the entire tab bar.
                  
To do       : A bit of a hack at the moment, needs to be properly 
              re-implemented.

*******************************************************************************/

void tabPane_forceRedraw(void)
{
   wimp_redrawstr redrawstr;

   redrawstr.w      = tabPane_handle;
   redrawstr.box.x0 = -4096;
   redrawstr.box.y0 = -4096;
   redrawstr.box.x1 = +4096;
   redrawstr.box.y1 = +4096;
   
   wimp_force_redraw(&redrawstr);                  
}

/*******************************************************************************

Function    : tabPane_releaseWindow

Parameters  : int - tab number

Returns     : void

Description : Release a window associated with a tab.  The window is re-opened
              at the top of the window stack, displaced downwards and to the
              right, to make it clear that it is no longer managed by the tab
              bar.

*******************************************************************************/
                                                            
void tabPane_releaseWindow(int tab)
{
   wimp_wstate wstate;

   wimp_get_wind_state(tabs.tab[tab].handle, &wstate); 
      
   wstate.o.behind = -1;
   wstate.o.x      = tabs.tab[tab].scx;
   wstate.o.y      = tabs.tab[tab].scy;
   wstate.o.box.x0 = active_state.o.box.x0 + 64; 
   wstate.o.box.y0 = active_state.o.box.y0 - 64;
   wstate.o.box.x1 = active_state.o.box.x1 + 64;
   wstate.o.box.y1 = active_state.o.box.y1 - 64;
      
   sendOpenWindowRequest(tabs.tab[tab].handle, &wstate.o); 
}
                                                                     
/*******************************************************************************

Function    : tabPane_selectTab 

Parameters  : int - index of tab to become the active tab

Returns     : void

Description : Select a new active tab, changing the colour an appearance of the
              icon, and making the corresponding window visible.  If another
              tab was previously active, the colour and appearance of the
              icon is changed and the corresponding window is hidden.  In that
              case, the dimensions and position of the new active window is
              made the same as those of the old active window.

*******************************************************************************/

void tabPane_selectTab(int tab)                                                         
{  
   wimp_redrawstr r;
   
   wimp_icon info;

   if (tab != active)
   {  
      if (active != -1)
      {                 
         // change colour and appearance of the old active tab

         wimp_get_icon_info(tabPane_handle, active*2, &info); 

         info.data.indirecttext.validstring[1] = '1';

         wimp_set_icon_state(tabPane_handle, 2*active, 
            (wimp_iconflags)((1U << 28) | wimp_IFILLED), 
            (wimp_iconflags)(0xF0000000U | wimp_IFILLED));    
         
         // hide the old active window

         wimp_get_wind_state(active_handle, &active_state); 
                                 
         active_state.o.behind = -3;

         sendOpenWindowRequest(active_handle, &active_state.o);

         // store scroll positions for when it is next active

         tabs.tab[active].scx = active_state.o.x;
         tabs.tab[active].scy = active_state.o.y;
      }

      // change the active tab

      active        = tab;                                                                                         
      active_handle = tabs.tab[active].handle;

      // change colour and appearance of the new active tab

      wimp_get_icon_info(tabPane_handle, 2*tab, &info); 

      info.data.indirecttext.validstring[1] = '2';

      wimp_set_icon_state(tabPane_handle, 2*tab, 
         (wimp_iconflags)((12U << 28) | wimp_IFILLED), 
         (wimp_iconflags)(0xF0000000U | wimp_IFILLED)); 

      // re-open adjust window
       
      adjust_state.o.behind = gui_handle;

      sendOpenWindowRequest(adjust_handle, &adjust_state.o);

      // re-open the new active tab              
      
      active_state.o.w      = active_handle;   
      active_state.o.behind = adjust_handle;
      active_state.o.x      = tabs.tab[active].scx;
      active_state.o.y      = tabs.tab[active].scy;
        
      sendOpenWindowRequest(active_handle, &active_state.o);
   }

   r.w      = tabPane_handle;
   r.box.x0 = tabPane_state.o.box.x0;
   r.box.y0 = tabPane_state.o.box.y0;
   r.box.x1 = tabPane_state.o.box.x1;
   r.box.y1 = tabPane_state.o.box.y1;

   wimp_force_redraw(&r);     
}

/*******************************************************************************

Function    : tabPane_deleteTab 

Parameters  : int - index of tab to be deleted

Returns     : void

Description : Delete a tab.  It isn't clear at the moment whether the correct
              behaviour should be to close the window or just detach it from 
              the tab bar.  For the moment, I'll go with detatching the window
              as it is easier and more conducive to debugging.

              Rather than re-form the tab bar, just relabel the existing icons
              and delete the last one, which hopefully is the most efficient
              approach.

*******************************************************************************/
                       
void tabPane_deleteTab(int tab)
{  
   // deselect the tab if currently active
                                         
   if (tabs.n == 1)
   {
      active        = -1;   
      active_handle = 0;        
   }
   else if (tab == active)
   {                 
      tabPane_selectTab(tab == 0 ? 1 : (tab-1));
   }            

   // release window

   tabPane_releaseWindow(tab);

   // update the tab bar     
       
   for (int i = tab + 1; i < tabs.n; i++)
   {         
      if (i == active)
      {
         active--;
      }           

      tabs.tab[i-1].handle = tabs.tab[i].handle;
      tabs.tab[i-1].scx    = tabs.tab[i].scx;
      tabs.tab[i-1].scy    = tabs.tab[i].scy;

      wimp_icon icon1, icon2;

      wimp_get_icon_info(tabPane_handle, (i-1)*2, &icon1); 
      wimp_get_icon_info(tabPane_handle, i*2,     &icon2); 

      strncpy(icon1.data.indirecttext.buffer, 
              icon2.data.indirecttext.buffer, 15);

      strncpy(icon1.data.indirecttext.validstring, 
              icon2.data.indirecttext.validstring, 2);

      wimp_set_icon_state(tabPane_handle, 2*(i-1), icon2.flags, 
         (wimp_iconflags)0xFFFFFFFF);
   }

   tabs.n--;               

   wimp_delete_icon(tabPane_handle, 2*tabs.n);
   wimp_delete_icon(tabPane_handle, 2*tabs.n+1);

   tabPane_forceRedraw();
}           

/*******************************************************************************

Function    : tabPane_mouseClickHandler

Parameters  : wimp_mousestr* - pointer to struct describing mouse event
              wimp_bbits     - additional information about mouse event
              Tabs*          - pointer to structure describing tabs

Returns     : void

Description : Respond to mouse button events over the tab pane, to determine
              which tab is clicked on, and make that the active tab.

*******************************************************************************/

static void tabPane_mouseClickHandler(wimp_mousestr *ms, 
                                      wimp_bbits mbits,
                                      Tabs *tabs)
{     
   wimp_icon info;

   if (ms->i%2 == 0)
   {
      // tab clicked

      wimp_get_icon_info(tabPane_handle, ms->i, &info);

      char *valid = info.data.indirecttext.validstring;
            
      if (valid[1] == '1')
      {
         tabPane_selectTab(ms->i/2);
      } 
   }
   else
   {
      // tab close button clicked      

      tabPane_deleteTab(ms->i/2);
   }
}          

/*******************************************************************************

Function    : tabPane_eventHandler 

Parameters  : wimp_eventstr* - pointer to struct describing the event
              void*          - pointer to workspace

Returns     : void

Description : Main event handler for the tab pane of a !tabby window.

*******************************************************************************/

void tabPane_eventHandler(wimp_eventstr *e, void *handle)
{
   switch(e->e)
   {
      case wimp_EOPEN:   // maximise or minimise window 
      {
         wimpt_noerr(wimp_open_wind(&e->data.o));

         break;
      }
      case wimp_ECLOSE:   // close window
      {
         wimpt_noerr(wimp_close_wind(e->data.o.w));
       
         break;
      } 
      case wimp_EBUT:
      {        
         tabPane_mouseClickHandler(&(e->data.but.m), e->data.but.b,
            (Tabs*)handle);

         break;
      }
   }
}

/*******************************************************************************

Function    : tabPane_create

Parameters  : void

Returns     : void

Description : Create a new tab pane for a !tabby window.

*******************************************************************************/

void tabPane_create(void)
{                        
   wimp_wind *window = template_syshandle("TabPane");

   if (window == 0)
   {
      exit(EXIT_FAILURE);
   }

   if (wimpt_complain(wimp_create_wind(window, &tabPane_handle)) != 0)
   {
      exit(EXIT_FAILURE);
   }

   win_register_event_handler(tabPane_handle, tabPane_eventHandler, 0);

   tabs.n = 0;
}

/*******************************************************************************

Function    : tabPane_addTab

Parameters  : wimp_w - handle of a window to be managed by !tabby

Returns     : void

Description : Create a new tab on the tab bar for the specified window and
              select it as the active tab.

*******************************************************************************/
                                 
void tabPane_addTab(wimp_w handle)
{                              
   // get info about the window
                      
   wimp_winfo *info = (wimp_winfo*)&block;

   info->w = handle;
   
   wimpt_complain(wimp_get_wind_info(info));
      
   char *label;

   if (info->info.titleflags & wimp_INDIRECT)
   {                                                                  
      char buffer[512];

      wimpt_complain(wimp_transferblock(identifyOwner(handle),
                         info->info.title.indirecttext.buffer,
                         wimpt_task(),
                         buffer,
                         info->info.title.indirecttext.bufflen));

      label = tabPane_extractLabel(buffer);
   }  
   else
   {                              
      char buffer[13];          

      buffer[0] = '\0';

      strncat(buffer, info->info.title.text, 12);

      label = strdup(buffer);
   }    

   // create tab icon

   wimp_icreate icreatestr;

   wimp_i icon;
                                                      
   icreatestr.w = tabPane_handle;                   
                      
   icreatestr.i.flags  = (wimp_iconflags)
                       ( wimp_ITEXT
                       | wimp_IVCENTRE
                       | wimp_INDIRECT
                       | wimp_IBORDER
                       | wimp_BCLICKAUTO << 12
                       | 7U << 24U     // foreground colour
                       | 1U << 28U);   // background colour

   icreatestr.i.data.indirecttext.buffer      = label;
   icreatestr.i.data.indirecttext.validstring = strdup("R1"); 
   icreatestr.i.data.indirecttext.bufflen     = strlen(label);
   icreatestr.i.box.x0 = tabs.n*TAB_WIDTH;
   icreatestr.i.box.y0 = -52 -16;
   icreatestr.i.box.x1 = icreatestr.i.box.x0 + TAB_WIDTH;
   icreatestr.i.box.y1 = -16;
       
   wimp_create_icon(&icreatestr, &icon);

   // create tab close icon

   icreatestr.i.flags  = (wimp_iconflags)
                       ( wimp_ISPRITE
                       | wimp_IHCENTRE
                       | wimp_IVCENTRE
                       | wimp_BCLICKAUTO << 12);

   strncpy(icreatestr.i.data.sprite_name, "close", 11); 
   icreatestr.i.box.x0 = icreatestr.i.box.x0 + TAB_WIDTH - 30;
   icreatestr.i.box.y0 = -52 + 16 -16;
   icreatestr.i.box.x1 = icreatestr.i.box.x0 + 13;
   icreatestr.i.box.y1 = -16 -16;

   wimp_create_icon(&icreatestr, &icon);

   // record window handle and scroll bar positions

   tabs.tab[tabs.n].handle = handle;
   tabs.tab[tabs.n].scx    = info->info.scx;
   tabs.tab[tabs.n].scy    = info->info.scy;

   tabPane_selectTab(tabs.n++); 
          
   // force redraw of tab bar

   wimp_redrawstr redrawstr;

   redrawstr.w      = tabPane_handle;
   redrawstr.box.x0 = icreatestr.i.box.x0;
   redrawstr.box.y0 = icreatestr.i.box.y0;
   redrawstr.box.x1 = icreatestr.i.box.x1;
   redrawstr.box.y1 = icreatestr.i.box.y1;

   wimp_force_redraw(&redrawstr);
}

        
/*******************************************************************************
*                                                                              * 
*                               Main GUI Functions                             * 
*                                                                              * 
*******************************************************************************/


/*******************************************************************************

Function    : gui_setState

Parameters  : int - new state

Returns     : void

Description : Update the state of the !tabby GUI, including updating the
              red/yellow/green LED.

*******************************************************************************/
                                                                                
void gui_setState(int newState)
{
   wimp_icon info;

   wimp_get_icon_info(gui_handle, 0, &info);

   char *valid = info.data.indirecttext.validstring;

   switch (newState)
   {          
      case STATE_SEARCHING:
      {         
         sprintf(valid, "R5;Sred_led,red_led");       

         state = STATE_SEARCHING;

         break;
      }
      case STATE_CAPTURING:
      {                 
         sprintf(valid, "R5;Syellow_led,yellow_led");       
         
         state = STATE_CAPTURING;

         break;
      }
      default:                   
      { 
         sprintf(valid, "R5;Sgreen_led,green_led");       

         state = STATE_LOCKED;
      }
   }                     

   // redraw the icon
     
   wimp_redrawstr r;

   r.w      = gui_handle;
   r.box.x0 = 0;
   r.box.y0 = -64;
   r.box.x1 = +64;
   r.box.y1 = 0;

   wimp_force_redraw(&r);
}

/*******************************************************************************

Function    : gui_open

Parameters  : wimp_openstr* - pointer to struct describing window parameters

Returns     : void

Description : Open a !tabby window, and the associated tab pane, so that it is 
              visible on-screen.

*******************************************************************************/

void gui_open(wimp_openstr *openstr)
{                            
   // has the width of the gui changed? 

   int oldWidth = gui_state.o.box.x1 - gui_state.o.box.x0;
   int newWidth = openstr->box.x1    - openstr->box.x0;

   if (newWidth != oldWidth)
   {
      // re-position right scroll icon

      wimp_box bbox;

      bbox.x0 = newWidth - 40 - 14;
      bbox.y0 = -60;
      bbox.x1 = newWidth - 14;
      bbox.y1 = -20;

      resizeIcon(gui_handle, 2, &bbox);

      wimp_redrawstr redrawstr;

      redrawstr.w      = gui_handle;
      redrawstr.box.x0 = min(newWidth, oldWidth) - 40 - 14;
      redrawstr.box.y0 = -60;
      redrawstr.box.x1 = max(newWidth, oldWidth) - 14;
      redrawstr.box.y1 = -20;
        
      wimp_force_redraw(&redrawstr); 

      wimpt_noerr(wimp_open_wind(&gui_state.o));
   }

   // open adjust size cover

   if (active_handle != 0)
   {
      //adjust_state.o.w      = adjust_handle;
      adjust_state.o.box.x0 = active_state.o.box.x1;   
      adjust_state.o.box.y0 = active_state.o.box.y0 - 40;
      adjust_state.o.box.x1 = active_state.o.box.x1 + 40;
      adjust_state.o.box.y1 = active_state.o.box.y0; 
      adjust_state.o.behind = openstr->behind;                 

      tabPane_state.o.behind = adjust_handle;      
   }                                      
   else
   {                       
      adjust_state.o.behind = -3;                                    

      tabPane_state.o.behind = openstr->behind;
   }

   wimpt_noerr(wimp_open_wind(&adjust_state.o));

   // open tab pane                       

   tabPane_state.o.box.x0 = openstr->box.x0 + 124;   
   tabPane_state.o.box.y0 = openstr->box.y0;
   tabPane_state.o.box.x1 = openstr->box.x1 - 60;
   tabPane_state.o.box.y1 = openstr->box.y1; 
         
   wimpt_noerr(wimp_open_wind(&tabPane_state.o));
                                        
   // open gui window
    
   gui_state.o.behind = tabPane_handle;

   memcpy(&gui_state.o.box, &openstr->box, sizeof(wimp_box));
         
   wimpt_noerr(wimp_open_wind(&gui_state.o));

   // re-open active window beneath the gui window

   if (active_handle != 0)
   { 
      int height = active_state.o.box.y1 - active_state.o.box.y0;
            
      active_state.o.box.x1 = gui_state.o.box.x1 - 40;
      active_state.o.box.y1 = gui_state.o.box.y0 - 2;
      active_state.o.box.x0 = gui_state.o.box.x0;
      active_state.o.box.y0 = active_state.o.box.y1 - height;
      active_state.o.behind = gui_handle;

      sendOpenWindowRequest(active_handle, &active_state.o);
   }
}

/*******************************************************************************

Function    : gui_closeDown
        
Parameters  : void

Returns     : void

Description : Called when a !tabby window is closed in order to restore all of
              the hidden windows. 

To do       : Free memory allocated to this !tabby window.

*******************************************************************************/

void gui_closeDown(void)
{                                                     
   // bring back all of the windows
     
   for (int i = 0; i < tabs.n; i++)
   {
      wimp_get_wind_state(tabs.tab[i].handle, &active_state); 
      
      active_state.o.behind = -1;
      active_state.o.x      = tabs.tab[i].scx;
      active_state.o.y      = tabs.tab[i].scy;
      
      sendOpenWindowRequest(active_handle, &active_state.o);
   }
}
   
/*******************************************************************************

Function    : gui_eventHandler

Parameters  : wimp_eventstr* - pointer to struct describing the event
              void*          - pointer to workspace (unused)

Returns     : void

Description : Main event handler for the !tabby window.

*******************************************************************************/

void gui_eventHandler(wimp_eventstr *e, void *handle)
{
   switch(e->e)
   {
      case wimp_EOPEN:   // maximise or minimise window 
      {
         gui_open(&(e->data.o));
                                            
         break;
      }
      case wimp_ECLOSE:   // close window
      {
         gui_closeDown();

         wimpt_noerr(wimp_close_wind(e->data.o.w));
         wimpt_noerr(wimp_close_wind(tabPane_handle));
       
         break;
      }
      case wimp_EBUT:   // mouse button change
      {     
         switch (e->data.but.m.i)
         {                                 
            case 0: // LED
            {                
               if (state == STATE_LOCKED)
               {
                  gui_setState(STATE_SEARCHING);
               }
               else
               {        
                  gui_setState(STATE_LOCKED);
               }

               break;
            }
            case 1: // left scroll button
            {                
               tabPane_scrollLeft();

               break;
            }
            case 2: // LED
            {                
               tabPane_scrollRight();

               break;
            }
         }

         break;
      }
   }
}

/*******************************************************************************

Function    : 

Parameters  : 

Returns     : 

Description : 

*******************************************************************************/
 
void adjust_eventHandler(wimp_eventstr *e, void *handle)
{                                                                                                   
   static int x, y;   // drag offsets 

   switch(e->e)                                 
   {   
      case wimp_ENULL:   // react to null event
      {   
         // adjust window is being dragged to re-size active window
            
         wimp_mousestr mousestr;

         wimp_openstr openstr;

         wimp_get_point_info(&mousestr);
           
         memcpy(&openstr, &gui_state.o, sizeof(wimp_openstr));

         active_state.o.box.x1 = mousestr.x + x;
         active_state.o.box.y0 = mousestr.y + y + 40;
         openstr.box.x1        = active_state.o.box.x1 + 40;
         openstr.behind        = -1;

         gui_open(&openstr);    

         break;
      }
      case wimp_EOPEN:    
      {
         wimpt_noerr(wimp_open_wind(&e->data.o));
                                    
         break;
      }
      case wimp_ECLOSE:   // close window
      {
         gui_closeDown();

         wimpt_noerr(wimp_close_wind(e->data.o.w));
         wimpt_noerr(wimp_close_wind(tabPane_handle));
       
         break;
      }                                          
      case wimp_EBUT:
      {
         if (e->data.but.m.bbits == 0x40)
         {                          
            // update the state of the active window 

            wimp_get_wind_state(active_handle, &active_state); 

            // update the window information
                   
            active_winfo.w = active_handle;

            wimpt_complain(wimp_get_wind_info(&active_winfo));

            // initiate drag operation

            wimp_dragstr dragstr;

            x = adjust_state.o.box.x0 - e->data.but.m.x;
            y = adjust_state.o.box.y0 - e->data.but.m.y;

            wimp_box parent;

            parent.x0 = active_state.o.box.x0 
                      + max(420, (active_winfo.info.minsize >> 16));  
            parent.y0 = active_state.o.box.y1
                      - active_winfo.info.box.y1
                      + active_winfo.info.box.y0
                      - 40 + 2;
            parent.x1 = active_state.o.box.x0 
                      + active_winfo.info.box.x1
                      - active_winfo.info.box.x0
                      + 40;
            parent.y1 = active_state.o.box.y1 
                      - max(124, active_winfo.info.minsize & 0xFFFF);

            LOG("adjust_eventHandler", "minsize = %#x : box.x0 = %d : box.y0 = %d : box.x1 = %d : box.y1 = %d", 
              active_winfo.info.box.x0,  
              active_winfo.info.box.y0,
              active_winfo.info.box.x1,
              active_winfo.info.box.y1,
              active_winfo.info.minsize);



            dragstr.window    = adjust_handle;
            dragstr.box.x0    = adjust_state.o.box.x0;
            dragstr.box.y0    = adjust_state.o.box.y0;
            dragstr.box.x1    = adjust_state.o.box.x1;
            dragstr.box.y1    = adjust_state.o.box.y1;
            dragstr.parent.x0 = parent.x0;
            dragstr.parent.y0 = parent.y0;
            dragstr.parent.x1 = parent.x1;
            dragstr.parent.y1 = parent.y1;
            dragstr.type      = wimp_USER_FIXED;

            wimp_drag_box(&dragstr);

            win_claim_idle_events(adjust_handle);
         }

         break;
      }
   }
}

BOOL adjust_unknownEventProcessor(wimp_eventstr *e, void *handle)
{      
   switch(e->e)
   {                                      
      case wimp_EUSERDRAG:
      {
         // drag operation finished, so null events no longer required

         win_claim_idle_events(adjust_handle-1);

         return TRUE;
      }
   }

   return FALSE;
}

/*******************************************************************************

Function    : gui_create

Parameters  : void

Returns     : void

Description : Create a new !tabby tab bar windowl.

*******************************************************************************/
           
void gui_create(void)
{                        
   // create the main gui

   wimp_wind *window = template_syshandle("Window");

   if (window == 0)
   {
      exit(EXIT_FAILURE);
   }

   if (wimpt_complain(wimp_create_wind(window, &gui_handle)) != 0)
   {
      exit(EXIT_FAILURE);
   }

   win_register_event_handler(gui_handle, gui_eventHandler, 0);

   // create the tab pane
                                       
   tabPane_create();
   
   // create the adjust window
         
   window = template_syshandle("adjustSize");

   if (window == 0)
   {
      exit(EXIT_FAILURE);
   }

   window->colours[0] = 0xFF;

   if (wimpt_complain(wimp_create_wind(window, &adjust_handle)) != 0)
   {
      exit(EXIT_FAILURE);
   }

   win_register_event_handler(adjust_handle, adjust_eventHandler, 0);

   win_add_unknown_event_processor(adjust_unknownEventProcessor, 0);

   // get initial window states

   wimp_get_wind_state(gui_handle, &gui_state);
   wimp_get_wind_state(adjust_handle, &adjust_state); 
   wimp_get_wind_state(tabPane_handle, &tabPane_state);

   gui_setState(STATE_LOCKED);
}
                                           
/*******************************************************************************

Function    : gui_monitor

Parameters  : int   - current time
              void* - pointer to workspace

Returns     : void

Description : Callback called by the alarm to repidly monitor the active 
              window, and respond appropriately e.g. if the title of the window
              changes, whenever the current state is STATE_LOCKED.  If the 
              state is STATE_SEARCHING, the application is waiting for a window 
              to be dragged over the tab bar, when this happens, the window is
              identified, the state is changed to STATE_CAPTURING and there
              is a delay of 1 second for the user to let go of the window.
              If the state is STATE_CAPTURING, a new active tab is created
              and the system moves back into STATE_LOCKED.

*******************************************************************************/

void gui_monitor(int time, void *handle)
{   
   int delay = 10;

   static wimp_w window = 0;
              
   if (state == STATE_SEARCHING)
   {           
      // seek window to capture by iterating through the window stack
                         
      if (!wimp_get_wind_state(gui_handle, &gui_state))
      { 
         wimp_wstate wstate;
                                        
         wstate.o.behind = gui_state.o.behind;

         while (wstate.o.behind != -1)         
         { 
            window = wstate.o.behind;

            wimp_get_wind_state(window, &wstate);                                  
           
            if (window != tabPane_handle)
            {
               if (intersects(&gui_state.o.box, &wstate.o.box))
               {
                  delay = 100;        
               
                  gui_setState(STATE_CAPTURING);

                  break;
               }
            }
         }
      }
   }
   else if (state == STATE_CAPTURING)
   {
      // re-open captured window beneath the tab bar
                     
      if (active_handle == 0)
      {
         wimp_get_wind_state(window, &active_state); 
      
         int height = active_state.o.box.y1 - active_state.o.box.y0;

         active_state.o.box.x0 = gui_state.o.box.x0;
         active_state.o.box.y0 = gui_state.o.box.y1 - height;
         active_state.o.box.x1 = gui_state.o.box.x1 - 40;
         active_state.o.box.y1 = gui_state.o.box.y0 - 2;
         active_state.o.w      = window;
         active_state.o.behind = adjust_handle;

         // re-open adjust button over the adjust size icon of the active window
      
         adjust_state.o.box.x0 = active_state.o.box.x1;
         adjust_state.o.box.y0 = active_state.o.box.y0 - 40;  
         adjust_state.o.box.x1 = adjust_state.o.box.x0 + 40;
         adjust_state.o.box.y1 = adjust_state.o.box.y0 + 40;
         adjust_state.o.behind = -1;  

         sendOpenWindowRequest(adjust_handle, &adjust_state.o);      

         sendOpenWindowRequest(active_handle, &active_state.o);      
      }

      tabPane_addTab(window);      
                                                        
      gui_setState(STATE_LOCKED);
   }
   else if (active_handle != 0)
   {                                
      // has the window title changed
   }
   else
   {
      // there is no active tab

      delay = 10;
   }

   alarm_set(alarm_timenow() + delay, gui_monitor, NULL);
}


/*******************************************************************************
*                                                                              * 
*                             Icon Bar and Menu                                * 
*                                                                              * 
*******************************************************************************/


/*******************************************************************************

Function    : info_about

Parameters  : void

Returns     : void

Description : Display program information dialog box.

*******************************************************************************/

static void info_about(void)
{
   dbox d = dbox_new("ProgInfo");

   if (d != NULL)
   {
      dbox_show(d);        
      dbox_fillin(d);       
      dbox_dispose(&d);     
   }
}

/*******************************************************************************

Function    : ipremenuproc

Parameters  : void* - pointer to workspace

Returns     : void

Description : Callback used to prepare the menu structure.  Currently just a
              stub.

*******************************************************************************/

static menu ipremenuproc(void *handle)
{
   return imenu;
}

/*******************************************************************************

Function    : imenuproc

Parameters  : void* - pointer to workspace
              char* - hit

Returns     : void

Description : Event handler for clicks on the menu.

*******************************************************************************/

static void imenuproc(void *handle, char *hit)
{
   switch (hit[0])  
   {                
      case IMENU_INFO:
      {
         info_about();

         break;
      }
      case IMENU_QUIT:
      {
         gui_closeDown();

         exit(EXIT_SUCCESS);

         break;
      }
   }
}

/*******************************************************************************

Function    : icon_left_click

Parameters  : wimp_i 

Returns     : void

Description : Callback called whenever the left mouse button is clicked on 
              the icon on the icon bar.  This is currently unused, but will
              later be implemented to allow multible !tabby tab bars.

*******************************************************************************/

static void icon_left_click(wimp_i icon)
{
}


/*******************************************************************************
*                                                                              * 
*                               Main Function                                  * 
*                                                                              * 
*******************************************************************************/


int main(void)
{                        
  event_setmask((wimp_emask)0);          
       
   wimpt_init(APP_NAME);

   res_init(APP_NAME);   

   template_init();              

   dbox_init();     

   baricon("!tabby", (int)resspr_area(), icon_left_click);

   imenu = menu_new(APP_NAME, MENU_ITEMS);
                    
   if (imenu == NULL)
   {
      return EXIT_FAILURE;
   }

   if (!event_attachmenumaker(win_ICONBAR, ipremenuproc, imenuproc, 0))
   {
      return EXIT_FAILURE;
   }                    

   // register icon menu and middle click handler 

   if (!event_attachmenumaker(win_ICONBAR, ipremenuproc, imenuproc, 0))
   {
      return FALSE;
   }               

   LOG("main", "Hello from %s", "Tabby");

   // open main window

   gui_create();

   gui_state.o.behind = -1;
   gui_open(&gui_state.o);

   // start monitoring windows


   alarm_init();

   alarm_set(alarm_timenow() + 100, gui_monitor, NULL);

   // main even processing loop

   while (TRUE) 
   {
      event_process();
   }
                    
   wimp_closedown();

   return EXIT_SUCCESS;
}

/******************************************************************************/
