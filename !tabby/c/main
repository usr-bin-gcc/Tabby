/*******************************************************************************

File        : c.main

Date        : Sunday 27th November 2021

Author      : Gavin Cawley

Description : Program to manage multiple (!SrcEdit) windows by grouping them 
              all under an external tab bar.

History     : 07/11/2021 v0.0.1 - started work
              21/11/2021 v0.1.0 - first properly working prototype
              27/11/2021 v0.2.0 - windows can now be independently released
                                  from the tab bar, but needs tidying up
              27/11/2021 v0.2.1 - fixed a bug when a non-active tab is released
                                  and the release of non-active windows made 
                                  more consistent in behaviour and minor 
                                  refactoring

To do       : (a) Scrolling tab pane to allow a large number of tabs.

              (b) Allow tabs to be rearranged by dragging.

              (c) Support for multiple independent tab bars.

Acks        : Many thanks to Stuart Swales for his help and advice.

*******************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
                 
#include "alarm.h"
#include "wimp.h"
#include "wimpt.h"
#include "resspr.h"
#include "baricon.h"
#include "res.h"
#include "event.h"
#include "menu.h"
#include "dbox.h"
#include "win.h"
#include "template.h"

#include "logger.h"
   
#define APP_NAME "Tabby"
#define MENU_ITEMS ">Info,Quit"
                 
#define MAX_TABS (256)
                    
#define IMENU_INFO 1
#define IMENU_QUIT 2

menu imenu;       

int active = -1;   // the currently active tab (-1 if no tabs)               

wimp_w gui_handle = 0, tabPane_handle = 0, active_handle = 0;

wimp_wstate gui_state, active_state, tabPane_state;
                 
#define STATE_SEARCHING 0
#define STATE_CAPTURING 1
#define STATE_LOCKED    2
                         
int state = STATE_SEARCHING;

typedef struct TabStr
{  
   wimp_w handle;

   int scx, scy;   // scroll bar positions
}
Tab;
          
typedef struct TabsStr
{
   Tab tab[MAX_TABS];

   int n;

   int active;
}
Tabs;             

Tabs tabs;

char block[32768];


/*******************************************************************************
*                                                                              * 
*                           Misc. Support Functions                            * 
*                                                                              * 
*******************************************************************************/


/*******************************************************************************

Function    : strdup

Parameters  : char* - pointer to string to be duplicated     

Returns     : char* - pointer to duplicate string

Description : Make a duplicate of a null-terminated string.  The duplicate is 
              allocated from the heap, so the caller has responsibility for 
              freeing it when no longer required.

*******************************************************************************/

#ifndef strdup

char *strdup(const char *s)
{
   size_t size = strlen(s) + 1;

   char *str = (char*)malloc(size);

   if (str != NULL) 
   {
      memcpy(str, s, size);
   }
 
   return str;
}

#endif

/*******************************************************************************

Function    : sendOpenWindowMessage

Parameters  : wimp_w        - window handle
              wimp_openstr* - pointer to window parameter structure

Returns     : void

Description : Send an Open_Window_Request message to the specified window.

*******************************************************************************/
                        
#define Wimp_SendMessage 0x400E7
       
void sendOpenWindowRequest(wimp_w handle, wimp_openstr* openstr)
{
   os_regset regs;

   regs.r[0] = (int)wimp_EOPEN;
   regs.r[1] = (int)openstr;
   regs.r[2] = (int)handle;

   wimpt_complain(os_swix(Wimp_SendMessage, &regs));
}

/*******************************************************************************

Function    : findTask

Parameters  : char* - name of WIMP task

Returns     : wimp_t - task handle

Description : Returns the task handle of the named task, or zero if no such
              task is currently running.

*******************************************************************************/

#define TaskManager_EnumerateTasks 0x42681

wimp_t findTask(char *task)
{
   int buffer[16];

   os_regset regs;

   regs.r[0] = 0;
                         
   do
   { 
      regs.r[1] = (int)&buffer;
      regs.r[2] = 64;

      wimpt_complain(os_swix(TaskManager_EnumerateTasks, &regs));

      for (int *block = buffer; block < (int*)regs.r[1]; block += 4)
      {                               
         if (strcmp(task, (char*)block[1]) == 0)
         {
            return block[0];
         }
      }  
   }
   while (regs.r[0] >= 0);

   return 0;
}
                                                                                
/*******************************************************************************

Function    : identifyOwner 

Parameters  : wimp_w - window handle

Returns     : wimp_t - task handle 

Description : Returns the task handle of the task that owns the specified
              window.  It is not clear what value is returned if an invalid
              window handle is used.

*******************************************************************************/
                                                            
wimp_t identifyOwner(wimp_w window)
{   
   os_regset regs;

   wimp_msghdr msg; 

   msg.size     = 20;   
   msg.your_ref = 0;  

   regs.r[0] = wimp_EACK; 
   regs.r[1] = (int)&msg;
   regs.r[2] = window;

   wimpt_complain(os_swix(Wimp_SendMessage, &regs));

   return (wimp_t)regs.r[2];   
}

/*******************************************************************************

Function    : intersects

Parameters  : wimp_box - pointer to bounding box of first window
              wimp_box - pointer to bounding box of second window

Returns     : int - 1 if boxes intersect and zero otherwise

Description : Determine whether one window overlaps another on-screen.

*******************************************************************************/

int intersects(wimp_box *x, wimp_box *y)
{                          
   if (x->x0 > y->x1) return 0;
   if (x->x1 < y->x0) return 0;
   if (x->y0 > y->y1) return 0;
   if (x->y1 < y->y0) return 0; 
   
   return 1;
}
                                                                                
/*******************************************************************************

Function    : different

Parameters  : wimp_box - pointer to box 
              wimp_box - pointer to box 

Returns     : int - one if boxes are different and zero otherwise

Description : Determine whether two wimp_box structures differ.  Typically used
              to determine whether a window has been moved or resized.

*******************************************************************************/
                                                    
int different(wimp_box *x, wimp_box *y)
{
   return ((x->x0 != y->x0) ||
           (x->y0 != y->y0) ||
           (x->x1 != y->x1) ||
           (x->y1 != y->y1));
} 


/*******************************************************************************
*                                                                              * 
*                                     Tab Pane                                 * 
*                                                                              * 
*******************************************************************************/

             
/*******************************************************************************

Function    : tabPane_extractLabel

Parameters  : char* - pointer to window title

Returns     : char* - pointer to tab label allocated on the heap

Description : Determine a suitable tab label from the title string of a 
              window managed by !tabby.  If the title is a file path, then
              the label is the name of the file, however if the path ends
              c.<file> or h.<file>, the label will be <file>.h or <file>.c
              respectively.  The label is allocated from the heap, so the
              caller has responsibility for freeing it when no longer required.

              Note that labels are always returned as 16 byte blocks so that
              tab labels can always be copied safely.

*******************************************************************************/
                      
char *tabPane_extractLabel(char *path)
{  
   char *token[256];

   char buffer[256];

   int n = 0;

   for (char *tok = strtok(path, "."); tok != NULL; tok = strtok(NULL, "."))
   {
      token[n++] = tok;
   }
                           
   if (n > 1)
   {
      if (strcmp(token[n-2], "c") == 0 || 
          strcmp(token[n-2], "h") == 0)
      {
         sprintf(buffer, "%s.%s", token[n-1], token[n-2]);
      }   
      else
      {
         sprintf(buffer, "%s", token[n-1]);
      }
   }                      
   else
   {
      sprintf(buffer, "%s", path);
   }
                    
   // return label in a fixed size (16 byte) buffer
       
   char *label = (char*)malloc(16);
   
   memcpy(label, buffer, 15);

   label[15] = '\0';

   return strdup(buffer); 
}

/*******************************************************************************

Function    : tabPane_forceRedraw

Parameters  : void

Returns     : void

Description : Force a redraw of the entire tab bar.
                  
To do       : A bit of a hack at the moment, needs to be properly 
              re-implemented.

*******************************************************************************/

void tabPane_forceRedraw(void)
{
   wimp_redrawstr redrawstr;

   redrawstr.w      = tabPane_handle;
   redrawstr.box.x0 = -4096;
   redrawstr.box.y0 = -4096;
   redrawstr.box.x1 = +4096;
   redrawstr.box.y1 = +4096;
   
   wimp_force_redraw(&redrawstr);                  
}

/*******************************************************************************

Function    : tabPane_releaseWindow

Parameters  : int - tab number

Returns     : void

Description : Release a window associated with a tab.  The window is re-opened
              at the top of the window stack, displaced downwards and to the
              right, to make it clear that it is no longer managed by the tab
              bar.

*******************************************************************************/
                                                            
void tabPane_releaseWindow(int tab)
{
   wimp_wstate wstate;

   wimp_get_wind_state(tabs.tab[tab].handle, &wstate); 
      
   wstate.o.behind = -1;
   wstate.o.x      = tabs.tab[tab].scx;
   wstate.o.y      = tabs.tab[tab].scy;
   wstate.o.box.x0 = active_state.o.box.x0 + 64; 
   wstate.o.box.y0 = active_state.o.box.y0 - 64;
   wstate.o.box.x1 = active_state.o.box.x1 + 64;
   wstate.o.box.y1 = active_state.o.box.y1 - 64;
      
   sendOpenWindowRequest(tabs.tab[tab].handle, &wstate.o); 
}
                                                                     
/*******************************************************************************

Function    : tabPane_selectTab 

Parameters  : int - index of tab to become the active tab

Returns     : void

Description : Select a new active tab, changing the colour an appearance of the
              icon, and making the corresponding window visible.  If another
              tab was previously active, the colour and appearance of the
              icon is changed and the corresponding window is hidden.  In that
              case, the dimensions and position of the new active window is
              made the same as those of the old active window.

*******************************************************************************/

void tabPane_selectTab(int tab)                                                         
{  
   wimp_redrawstr r;
   
   wimp_icon info;

   if (tab != active)
   {  
      if (active != -1)
      {                 
         // change colour and appearance of the old active tab

         wimp_get_icon_info(tabPane_handle, active*2, &info); 

         info.data.indirecttext.validstring[1] = '1';

         wimp_set_icon_state(tabPane_handle, 2*active, 
            (wimp_iconflags)((1U << 28) | wimp_IFILLED), 
            (wimp_iconflags)(0xF0000000U | wimp_IFILLED));    
         
         // hide the old active window

         wimp_get_wind_state(active_handle, &active_state); 
                                 
         active_state.o.behind = -3;

         sendOpenWindowRequest(active_handle, &active_state.o);

         // store scroll positions for when it is next active

         tabs.tab[active].scx = active_state.o.x;
         tabs.tab[active].scy = active_state.o.y;
      }

      // change the active tab

      active        = tab;                                                                                         
      active_handle = tabs.tab[active].handle;

      // change colour and appearance of the new active tab

      wimp_get_icon_info(tabPane_handle, 2*tab, &info); 

      info.data.indirecttext.validstring[1] = '2';

      wimp_set_icon_state(tabPane_handle, 2*tab, 
         (wimp_iconflags)((12U << 28) | wimp_IFILLED), 
         (wimp_iconflags)(0xF0000000U | wimp_IFILLED)); 

      // re-open the new active tab              
      
      active_state.o.w      = active_handle;   
      active_state.o.behind = gui_handle;
      active_state.o.x      = tabs.tab[active].scx;
      active_state.o.y      = tabs.tab[active].scy;
        
      sendOpenWindowRequest(active_handle, &active_state.o);
   }

   r.w      = tabPane_handle;
   r.box.x0 = tabPane_state.o.box.x0;
   r.box.y0 = tabPane_state.o.box.y0;
   r.box.x1 = tabPane_state.o.box.x1;
   r.box.y1 = tabPane_state.o.box.y1;

   wimp_force_redraw(&r);     
}

/*******************************************************************************

Function    : tabPane_deleteTab 

Parameters  : int - index of tab to be deleted

Returns     : void

Description : Delete a tab.  It isn't clear at the moment whether the correct
              behaviour should be to close the window or just detach it from 
              the tab bar.  For the moment, I'll go with detatching the window
              as it is easier and more conducive to debugging.

              Rather than re-form the tab bar, just relabel the existing icons
              and delete the last one, which hopefully is the most efficient
              approach.

*******************************************************************************/
                       
void tabPane_deleteTab(int tab)
{  
   // deselect the tab if currently active
                                         
   if (tabs.n == 1)
   {
      active        = -1;   
      active_handle = 0;        
   }
   else if (tab == active)
   {                 
      tabPane_selectTab(tab == 0 ? 1 : (tab-1));
   }            

   // release window

   tabPane_releaseWindow(tab);

   // update the tab bar     
       
   for (int i = tab + 1; i < tabs.n; i++)
   {         
      if (i == active)
      {
         active--;
      }           

      tabs.tab[i-1].handle = tabs.tab[i].handle;
      tabs.tab[i-1].scx    = tabs.tab[i].scx;
      tabs.tab[i-1].scy    = tabs.tab[i].scy;

      wimp_icon icon1, icon2;

      wimp_get_icon_info(tabPane_handle, (i-1)*2, &icon1); 
      wimp_get_icon_info(tabPane_handle, i*2,     &icon2); 

      strncpy(icon1.data.indirecttext.buffer, 
              icon2.data.indirecttext.buffer, 15);

      strncpy(icon1.data.indirecttext.validstring, 
              icon2.data.indirecttext.validstring, 2);

      wimp_set_icon_state(tabPane_handle, 2*(i-1), icon2.flags, 
         (wimp_iconflags)0xFFFFFFFF);
   }

   tabs.n--;               

   wimp_delete_icon(tabPane_handle, 2*tabs.n);
   wimp_delete_icon(tabPane_handle, 2*tabs.n+1);

   tabPane_forceRedraw();
}           

/*******************************************************************************

Function    : tabPane_mouseClickHandler

Parameters  : wimp_mousestr* - pointer to struct describing mouse event
              wimp_bbits     - additional information about mouse event
              Tabs*          - pointer to structure describing tabs

Returns     : void

Description : Respond to mouse button events over the tab pane, to determine
              which tab is clicked on, and make that the active tab.

*******************************************************************************/

static void tabPane_mouseClickHandler(wimp_mousestr *ms, 
                                      wimp_bbits mbits,
                                      Tabs *tabs)
{     
   wimp_icon info;

   if (ms->i%2 == 0)
   {
      // tab clicked

      wimp_get_icon_info(tabPane_handle, ms->i, &info);

      char *valid = info.data.indirecttext.validstring;
            
      if (valid[1] == '1')
      {
         tabPane_selectTab(ms->i/2);
      } 
   }
   else
   {
      // tab close button clicked      

      tabPane_deleteTab(ms->i/2);
   }
}          

/*******************************************************************************

Function    : tabPane_eventHandler 

Parameters  : wimp_eventstr* - pointer to struct describing the event
              void*          - pointer to workspace

Returns     : void

Description : Main event handler for the tab pane of a !tabby window.

*******************************************************************************/

void tabPane_eventHandler(wimp_eventstr *e, void *handle)
{
   switch(e->e)
   {
      case wimp_EOPEN:   // maximise or minimise window 
      {
         wimpt_noerr(wimp_open_wind(&e->data.o));

         break;
      }
      case wimp_ECLOSE:   // close window
      {
         wimpt_noerr(wimp_close_wind(e->data.o.w));
       
         break;
      } 
      case wimp_EBUT:
      {        
         tabPane_mouseClickHandler(&(e->data.but.m), e->data.but.b,
            (Tabs*)handle);

         break;
      }
   }
}

/*******************************************************************************

Function    : tabPane_create

Parameters  : void

Returns     : void

Description : Create a new tab pane for a !tabby window.

*******************************************************************************/

void tabPane_create(void)
{                        
   wimp_wind *window = template_syshandle("TabPane");

   if (window == 0)
   {
      exit(EXIT_FAILURE);
   }

   if (wimpt_complain(wimp_create_wind(window, &tabPane_handle)) != 0)
   {
      exit(EXIT_FAILURE);
   }

   win_register_event_handler(tabPane_handle, tabPane_eventHandler, 0);

   tabs.n = 0;
}

/*******************************************************************************

Function    : tabPane_addTab

Parameters  : wimp_w - handle of a window to be managed by !tabby

Returns     : void

Description : Create a new tab on the tab bar for the specified window and
              select it as the active tab.

*******************************************************************************/
                                 
void tabPane_addTab(wimp_w handle)
{                              
   // get info about the window
                      
   wimp_winfo *info = (wimp_winfo*)&block;

   info->w = handle;
   
   wimpt_complain(wimp_get_wind_info(info));
      
   char *label;

   if (info->info.titleflags & wimp_INDIRECT)
   {                                                                  
      char buffer[512];

      wimpt_complain(wimp_transferblock(identifyOwner(handle),
                         info->info.title.indirecttext.buffer,
                         wimpt_task(),
                         buffer,
                         info->info.title.indirecttext.bufflen));

      label = tabPane_extractLabel(buffer);
   }  
   else
   {                              
      char buffer[13];          

      buffer[0] = '\0';

      strncat(buffer, info->info.title.text, 12);

      label = strdup(buffer);
   }    

   // create tab icon

   wimp_icreate icreatestr;

   wimp_i icon;
                                                      
   icreatestr.w = tabPane_handle;                   
                      
   icreatestr.i.flags  = (wimp_iconflags)
                       ( wimp_ITEXT
                       | wimp_IVCENTRE
                       | wimp_INDIRECT
                       | wimp_IBORDER
                       | wimp_BCLICKAUTO << 12
                       | 7U << 24U     // foreground colour
                       | 1U << 28U);   // background colour

   icreatestr.i.data.indirecttext.buffer      = label;
   icreatestr.i.data.indirecttext.validstring = strdup("R1"); 
   icreatestr.i.data.indirecttext.bufflen     = strlen(label);
   icreatestr.i.box.x0 = tabs.n*240;
   icreatestr.i.box.y0 = -52 -16;
   icreatestr.i.box.x1 = icreatestr.i.box.x0 + 240;
   icreatestr.i.box.y1 = -16;
       
   wimp_create_icon(&icreatestr, &icon);

   // create tab close icon

   icreatestr.i.flags  = (wimp_iconflags)
                       ( wimp_ISPRITE
                       | wimp_IHCENTRE
                       | wimp_IVCENTRE
                       | wimp_BCLICKAUTO << 12);

   strncpy(icreatestr.i.data.sprite_name, "close", 11); 
   icreatestr.i.box.x0 = icreatestr.i.box.x0 + 200;
   icreatestr.i.box.y0 = -52 + 16 -16;
   icreatestr.i.box.x1 = icreatestr.i.box.x0 + 20;
   icreatestr.i.box.y1 = -16 -16;

   wimp_create_icon(&icreatestr, &icon);

   // record window handle and scroll bar positions

   tabs.tab[tabs.n].handle = handle;
   tabs.tab[tabs.n].scx    = info->info.scx;
   tabs.tab[tabs.n].scy    = info->info.scy;

   tabPane_selectTab(tabs.n++); 
          
   // force redraw of tab bar

   wimp_redrawstr redrawstr;

   redrawstr.w      = tabPane_handle;
   redrawstr.box.x0 = icreatestr.i.box.x0;
   redrawstr.box.y0 = icreatestr.i.box.y0;
   redrawstr.box.x1 = icreatestr.i.box.x1;
   redrawstr.box.y1 = icreatestr.i.box.y1;

   wimp_force_redraw(&redrawstr);
}

        
/*******************************************************************************
*                                                                              * 
*                               Main GUI Functions                             * 
*                                                                              * 
*******************************************************************************/


/*******************************************************************************

Function    : gui_setState

Parameters  : int - new state

Returns     : void

Description : Update the state of the !tabby GUI, including updating the
              red/yellow/green LED.

*******************************************************************************/
                                                                                
void gui_setState(int newState)
{
   wimp_icon info;

   wimp_get_icon_info(gui_handle, 0, &info);

   char *valid = info.data.indirecttext.validstring;

   switch (newState)
   {          
      case STATE_SEARCHING:
      {         
         sprintf(valid, "R5;Sred_led,red_led");       

         state = STATE_SEARCHING;

         break;
      }
      case STATE_CAPTURING:
      {                 
         sprintf(valid, "R5;Syellow_led,yellow_led");       
         
         state = STATE_CAPTURING;

         break;
      }
      default:                   
      { 
         sprintf(valid, "R5;Sgreen_led,green_led");       

         state = STATE_LOCKED;
      }
   }                     

   // redraw the icon
     
   wimp_redrawstr r;

   r.w      = gui_handle;
   r.box.x0 = 0;
   r.box.y0 = -64;
   r.box.x1 = +64;
   r.box.y1 = 0;

   wimp_force_redraw(&r);
}

/*******************************************************************************

Function    : gui_open

Parameters  : wimp_openstr* - pointer to struct describing window parameters

Returns     : void

Description : Open a !tabby window, and the associated tab pane, so that it is 
              visible on-screen.

*******************************************************************************/

void gui_open(wimp_openstr *openstr)
{   
   // open tab pane
          
   openstr->box.x0 = openstr->box.x0 + 80;                    
   openstr->w      = tabPane_handle;
         
   wimpt_noerr(wimp_open_wind(openstr));

    // open main window

    openstr->w      = gui_handle;
    openstr->box.x0 = openstr->box.x0 - 80;                    
    openstr->behind = tabPane_handle;
            
    wimpt_noerr(wimp_open_wind(openstr));
}

/*******************************************************************************

Function    : gui_closeDown
        
Parameters  : void

Returns     : void

Description : Called when a !tabby window is closed in order to restore all of
              the hidden windows. 

To do       : Free memory allocated to this !tabby window.

*******************************************************************************/

void gui_closeDown(void)
{                                                     
   // bring back all of the windows
     
   for (int i = 0; i < tabs.n; i++)
   {
      wimp_get_wind_state(tabs.tab[i].handle, &active_state); 
      
      active_state.o.behind = -1;
      active_state.o.x      = tabs.tab[i].scx;
      active_state.o.y      = tabs.tab[i].scy;
      
      sendOpenWindowRequest(active_handle, &active_state.o);
   }
}
   
/*******************************************************************************

Function    : gui_eventHandler

Parameters  : wimp_eventstr* - pointer to struct describing the event
              void*          - pointer to workspace (unused)

Returns     : void

Description : Main event handler for the !tabby window.

*******************************************************************************/

void gui_eventHandler(wimp_eventstr *e, void *handle)
{
   switch(e->e)
   {
      case wimp_EOPEN:   // maximise or minimise window 
      {
         if (active_handle != 0)
         {     
            wimp_get_wind_state(active_handle, &active_state); 

            int height = active_state.o.box.y1 - active_state.o.box.y0;
            
            active_state.o.w      = active_handle;
            active_state.o.box.x1 = e->data.o.box.x1 - 40;
            active_state.o.box.y1 = e->data.o.box.y0 - 40 - 2;
            active_state.o.box.x0 = e->data.o.box.x0;
            active_state.o.box.y0 = active_state.o.box.y1 - height;
            active_state.o.behind = e->data.o.behind;

            sendOpenWindowRequest(active_handle, &active_state.o);
         }
                                      
         gui_open(&(e->data.o));
      
         break;
      }
      case wimp_ECLOSE:   // close window
      {
         gui_closeDown();

         wimpt_noerr(wimp_close_wind(e->data.o.w));
         wimpt_noerr(wimp_close_wind(tabPane_handle));
       
         break;
      }
      case wimp_EBUT:   // mouse button change
      {                                      
         if (e->data.but.m.i == 0)
         {                  
            if (state == STATE_LOCKED)
            {
               gui_setState(STATE_SEARCHING);
            }
            else
            {        
               gui_setState(STATE_LOCKED);
            }
         }

         break;
      }
   }
}

/*******************************************************************************

Function    : gui_create

Parameters  : void

Returns     : void

Description : Create a new !tabby tab bar windowl.

*******************************************************************************/
           
void gui_create(void)
{                        
   wimp_wind *window = template_syshandle("Window");

   if (window == 0)
   {
      exit(EXIT_FAILURE);
   }

   if (wimpt_complain(wimp_create_wind(window, &gui_handle)) != 0)
   {
      exit(EXIT_FAILURE);
   }

   win_register_event_handler(gui_handle, gui_eventHandler, 0);

   tabPane_create();
}
                                           
/*******************************************************************************

Function    : gui_monitor

Parameters  : int   - current time
              void* - pointer to workspace

Returns     : void

Description : Callback called by the alarm to repidly monitor the active 
              window, and respond appropriately if it is moved or resized,
              whenever the current state is STATE_LOCKED.  If the state is
              STATE_SEARCHING, the application is waiting for a window to
              be dragged over the tab bar, when this happens, the window is
              identified, the state is changed to STATE_CAPTURING and there
              is a delay of 1 second for the user to let go of the window.
              If the state is STATE_CAPTURING, a new active tab is created
              and the system moves back into STATE_LOCKED.

*******************************************************************************/

void gui_monitor(int time, void *handle)
{   
   int delay = 1;

   static wimp_w window = 0;
              
   if (state == STATE_SEARCHING)
   {           
      // seek to capture a window  
                         
      if (!wimp_get_wind_state(gui_handle, &gui_state))
      { 
         wimp_wstate wstate;
                                        
         wstate.o.behind = gui_state.o.behind;

         while (wstate.o.behind != -1)         
         { 
            window = wstate.o.behind;

            wimp_get_wind_state(window, &wstate);                                  
           
            if (window != tabPane_handle)
            {
               if (intersects(&gui_state.o.box, &wstate.o.box))
               {
                  delay = 100;        
               
                  gui_setState(STATE_CAPTURING);

                  break;
               }
            }
         }
      }
   }
   else if (state == STATE_CAPTURING)
   {
      // re-open captured window beneath the tab bar
                     
      if (active_handle == 0)
      {
         wimp_get_wind_state(window, &active_state); 
      
         int height = active_state.o.box.y1 - active_state.o.box.y0;

         active_state.o.box.x1 = gui_state.o.box.x1 - 40;
         active_state.o.box.y1 = gui_state.o.box.y0 - 40 - 2;
         active_state.o.box.x0 = gui_state.o.box.x0;
         active_state.o.box.y0 = gui_state.o.box.y1 - height;
         active_state.o.w      = window;
         active_state.o.behind = -1;

         sendOpenWindowRequest(active_handle, &active_state.o);      
      }

      tabPane_addTab(window);      
                                                        
      gui_setState(STATE_LOCKED);
   }
   else if (active_handle != 0)
   {                            
      // monitor behaviour of the captured window

      wimp_wstate wstate;

      wimp_get_wind_state(active_handle, &wstate); 
      
      // has the window been resized or moved?

      if (different(&active_state.o.box, &wstate.o.box))
      {
         memcpy(&active_state, &wstate, sizeof(wimp_wstate));

         gui_state.o.box.x0 = active_state.o.box.x0;
         gui_state.o.box.y0 = active_state.o.box.y1 + 40 + 2;
         gui_state.o.box.x1 = active_state.o.box.x1 + 40;
         gui_state.o.box.y1 = gui_state.o.box.y0 + 64;
         gui_state.o.behind = active_handle;

         gui_open(&gui_state.o);
      }
   }
   else
   {
      // there is no active tab

      delay = 10;
   }

   alarm_set(alarm_timenow() + delay, gui_monitor, NULL);
}


/*******************************************************************************
*                                                                              * 
*                             Icon Bar and Menu                                * 
*                                                                              * 
*******************************************************************************/


/*******************************************************************************

Function    : info_about

Parameters  : void

Returns     : void

Description : Display program information dialog box.

*******************************************************************************/

static void info_about(void)
{
   dbox d = dbox_new("ProgInfo");

   if (d != NULL)
   {
      dbox_show(d);        
      dbox_fillin(d);       
      dbox_dispose(&d);     
   }
}

/*******************************************************************************

Function    : ipremenuproc

Parameters  : void* - pointer to workspace

Returns     : void

Description : Callback used to prepare the menu structure.  Currently just a
              stub.

*******************************************************************************/

static menu ipremenuproc(void *handle)
{
   return imenu;
}

/*******************************************************************************

Function    : imenuproc

Parameters  : void* - pointer to workspace
              char* - hit

Returns     : void

Description : Event handler for clicks on the menu.

*******************************************************************************/

static void imenuproc(void *handle, char *hit)
{
   switch (hit[0])  
   {                
      case IMENU_INFO:
      {
         info_about();

         break;
      }
      case IMENU_QUIT:
      {
         gui_closeDown();

         exit(EXIT_SUCCESS);

         break;
      }
   }
}

/*******************************************************************************

Function    : icon_left_click

Parameters  : wimp_i 

Returns     : void

Description : Callback called whenever the left mouse button is clicked on 
              the icon on the icon bar.  This is currently unused, but will
              later be implemented to allow multible !tabby tab bars.

*******************************************************************************/

static void icon_left_click(wimp_i icon)
{
}


/*******************************************************************************
*                                                                              * 
*                               Main Function                                  * 
*                                                                              * 
*******************************************************************************/


int main(void)
{                                         
   wimpt_init(APP_NAME);

   res_init(APP_NAME);   

   template_init();              

   dbox_init();     

   gui_create();

   baricon("!tabby", (int)resspr_area(), icon_left_click);

   imenu = menu_new(APP_NAME, MENU_ITEMS);
                    
   if (imenu == NULL)
   {
      return EXIT_FAILURE;
   }

   if (!event_attachmenumaker(win_ICONBAR, ipremenuproc, imenuproc, 0))
   {
      return EXIT_FAILURE;
   }                    

   // register icon menu and middle click handler 

   if (!event_attachmenumaker(win_ICONBAR, ipremenuproc, imenuproc, 0))
   {
      return FALSE;
   }               

   LOG("main", "Hello from %s", "Tabby");

   // open main window

   wimpt_complain(wimp_get_wind_state(gui_handle, &gui_state));

   gui_open(&gui_state.o);

   // start monitoring windows

   gui_setState(STATE_LOCKED);

   alarm_init();

   alarm_set(alarm_timenow() + 100, gui_monitor, NULL);

   // main even processing loop

   while (TRUE) 
   {
      event_process();
   }
                    
   wimp_closedown();

   return EXIT_SUCCESS;
}

/******************************************************************************/
